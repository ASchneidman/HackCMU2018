313
1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 17, 18, 18, 19, 19, 20, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 40, 42, 43, 45, 46, 46, 47, 48, 50, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 83, 83, 84, 85, 86, 88, 89, 91, 92, 93, 94, 96, 97, 97, 98, 99, 100, 101, 103, 104, 104, 105, 106, 107, 107, 108, 110, 110, 110, 111, 112, 113, 114, 116, 117, 117, 117, 118, 118, 119, 119, 119, 120, 120, 121, 121, 122, 122, 123, 124, 125, 126, 127, 128, 129, 131, 132, 134, 135, 136, 138, 139, 139, 139, 140, 140, 141, 141, 142, 142, 143, 145, 146, 146, 146, 147, 147, 148, 148, 149, 149, 149, 150, 151, 152, 154, 155, 156, 158, 160, 160, 160, 161, 162, 163, 164, 165, 165, 166, 168, 169, 170, 170, 170, 171, 172, 173, 174, 176, 177, 177, 177, 178, 179, 180, 181, 183, 185, 186, 186, 187, 187, 187, 188, 189, 190, 191, 193, 194, 194, 194, 195, 196, 197, 198, 200, 202, 203, 204, 204, 204, 205, 206, 207, 208, 210, 211, 211, 211, 212, 213, 214, 215, 216, 218, 219, 220, 220, 220, 221, 222, 223, 224, 226, 227, 227, 227, 228, 229, 230, 231, 233, 235, 236, 237, 237, 237, 238, 239, 240, 241, 243, 244, 244, 244, 245, 246, 247, 248, 250, 252, 253, 254, 254, 254, 255, 256, 256, 256, 257, 258, 259, 260, 262, 263, 263, 263, 264, 265, 266, 267, 269, 271, 272, 273, 273, 273, 274, 275, 276, 277, 279, 280, 280, 280, 281, 282, 283, 284, 285, 286, 287, 287, 288, 288, 289, 291, 292, 293, 295
#include "common.h"
#include <xpwn/pwnutil.h>
#include <xpwn/plist.h>
#include <xpwn/outputstate.h>
#include <hfs/hfslib.h>
#include <xpwn/ibootim.h>
#include "libibooter.h"
#include <iostream>
#include <string.h>

using namespace ibooter;
using namespace std;

char endianness;

void TestByteOrder()
{
	short int word = 0x0001;
	char *byte = (char *) &word;
	endianness = byte[0] ? IS_LITTLE_ENDIAN : IS_BIG_ENDIAN;
}

int main(int argc, char *argv[]) 
{
	const char* bundleRoot = "FirmwareBundles/";
	const char *pResponse = NULL;
	CIBootConn conn;
	ERR_CODE code;
	OutputState* ipswContents;
	char* bundlePath;
	Dictionary* info;
	StringValue* kernelValue;
	AbstractFile* ramdisk;

	AbstractFile* applelogo = NULL;
	AbstractFile* recoverymode = NULL;
	AbstractFile* iboot = NULL;
	int i;

	TestByteOrder();

	applelogo = NULL;
	recoverymode = NULL;

	if(argc < 2) {
		cout << "usage: " << argv[0] << " <input ipsw> [-b <bootimage.png>] [-r <recoveryimage.png>]" << endl;
		return 1;
	}

	for(i = 2; i < argc; i++) {	
		if(strcmp(argv[i], "-b") == 0) {
			applelogo = createAbstractFileFromFile(fopen(argv[i + 1], "rb"));
			if(!applelogo) {
				cout << "cannot open " << argv[i + 1] << endl;
				return 1;
			}
			i++;
			continue;
		}

		if(strcmp(argv[i], "-r") == 0) {
			recoverymode = createAbstractFileFromFile(fopen(argv[i + 1], "rb"));
			if(!recoverymode) {
				cout << "cannot open " << argv[i + 1] << endl;
				return 1;
			}
			i++;
			continue;
		}
		if(strcmp(argv[i], "-i") == 0) {
			iboot = createAbstractFileFromFile(fopen(argv[i + 1], "rb"));
			if(!iboot) {
				cout << "cannot open " << argv[i + 1] << endl;
				return 1;
			}
			i++;
			continue;
		}
	}

	cout << " ... Connecting" << endl;
	if ((code = conn.Connect()) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		return 1;
	}

	cout << " ... Loading IPSW" << endl;
	info = parseIPSW(argv[1], bundleRoot, &bundlePath, &ipswContents);

	if(!info) {
		printf("error: cannot load IPSW file\n");
		exit(1);
	}

	cout << " ... Opening ramdisk" << endl;
	AbstractFile* ramdiskSrc = createAbstractFileFromFile(fopen("ramdisk.dmg", "rb"));
	if(!ramdiskSrc) {
		cout << "error: cannot find ramdisk.dmg!" << endl;
		exit(1);
	}

	size_t bufferSize = ramdiskSrc->getLength(ramdiskSrc);
	void* buffer = (void*) malloc(bufferSize);
	cout << " ... Reading ramdisk" << endl;
	ramdiskSrc->read(ramdiskSrc, buffer, bufferSize);
	io_func* myRamdisk = IOFuncFromAbstractFile(createAbstractFileFromMemoryFile(&buffer, &bufferSize));
	Volume* ramdiskVolume = openVolume(myRamdisk);

	Dictionary* ibootDict = (Dictionary*)getValueByKey((Dictionary*)getValueByKey(info, "FirmwarePatches"), "iBoot");
	if(!ibootDict) {
		cout << "Error reading iBoot info" << endl;
		exit(1);
	}

	if(!iboot) {
		add_hfs(ramdiskVolume, getFileFromOutputState(&ipswContents, ((StringValue*)getValueByKey(ibootDict, "File"))->value), "/ipwner/iboot.img2");
		StringValue* patchValue = (StringValue*) getValueByKey(ibootDict, "Patch");
		char* patchPath = (char*) malloc(sizeof(char) * (strlen(bundlePath) + strlen(patchValue->value) + 2));
		strcpy(patchPath, bundlePath);
		strcat(patchPath, "/");
		strcat(patchPath, patchValue->value);
		printf("patching /ipwner/iboot.img2 (%s)... ", patchPath);
		doPatchInPlace(ramdiskVolume, "/ipwner/iboot.img2", patchPath);
		free(patchPath);
	} else {
		cout << "adding custom iboot" << endl;
		add_hfs(ramdiskVolume, iboot, "/ipwner/iboot.img2");
	}

	if(applelogo || recoverymode) {
		cout << " ... Adding boot logos" << endl;

		StringValue* fileValue;
		void* imageBuffer;
		size_t imageSize;

		if(applelogo) {
			fileValue = (StringValue*) getValueByKey((Dictionary*)getValueByKey((Dictionary*)getValueByKey(info, "FirmwarePatches"), "AppleLogo"), "File");
			printf("replacing %s\n", fileValue->value); fflush(stdout);
			ASSERT((imageBuffer = replaceBootImage(getFileFromOutputState(&ipswContents, fileValue->value), NULL, NULL, applelogo, &imageSize)) != NULL, "failed to use new image");
			add_hfs(ramdiskVolume, createAbstractFileFromMemory(&imageBuffer, imageSize), "/ipwner/logo.img2");
		}

		if(recoverymode) {
			fileValue = (StringValue*) getValueByKey((Dictionary*)getValueByKey((Dictionary*)getValueByKey(info, "FirmwarePatches"), "RecoveryMode"), "File");
			printf("replacing %s\n", fileValue->value); fflush(stdout);
			ASSERT((imageBuffer = replaceBootImage(getFileFromOutputState(&ipswContents, fileValue->value), NULL, NULL, recoverymode, &imageSize)) != NULL, "failed to use new image");
			add_hfs(ramdiskVolume, createAbstractFileFromMemory(&imageBuffer, imageSize), "/ipwner/recovery.img2");			
		}

	}

	cout << " ... Finalizing ramdisk" << endl;
	closeVolume(ramdiskVolume);
	CLOSE(myRamdisk);

	ramdisk = createAbstractFileFromMemoryFile(&buffer, &bufferSize);

	kernelValue = (StringValue*) getValueByKey((Dictionary*)getValueByKey((Dictionary*)getValueByKey(info, "FirmwarePatches"), "KernelCache"), "File");
	if(!kernelValue) {
		cout << "Unable to determine kernel cache file name from bundle plist!";
		return 1;
	}
	
	cout << " ... Will send kernel at: " << kernelValue->value << endl;

	cout << " ... Sending ramdisk" << endl;
	if ((code = conn.SendFile(ramdisk, 0x09400000)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	cout << "Response: " << pResponse << endl;

	cout << " ... Sending kernelcache" << endl;
	if ((code = conn.SendFile(getFileFromOutputState(&ipswContents, kernelValue->value), 0x09000000)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	cout << "Response: " << pResponse << endl;

	cout << " ... Clearing boot arguments" << endl;
	if ((code = conn.SendCommand("setenv boot-args \"\"\n")) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}
	cout << "Response: " << pResponse << endl;

	cout << " ... Setting auto-reboot" << endl;
	if ((code = conn.SendCommand("setenv auto-boot true\n")) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	cout << "Response: " << pResponse << endl;

	cout << " ... Saving environment" << endl;
	if ((code = conn.SendCommand("saveenv\n")) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	cout << "Response: " << pResponse << endl;

	cout << " ... Setting up ramdisk" << endl;
	char bootArgsBuf[1024];
	sprintf(bootArgsBuf, "setenv boot-args \"-v pmd0=0x09400000.0x%x pmd1=0x8000000.0x8000000 rd=md0\"\n", bufferSize);
	if ((code = conn.SendCommand(bootArgsBuf)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	cout << "Response: " << pResponse << endl;

	cout << " ... Booting" << endl;
	if ((code = conn.SendCommand("bootx\n")) != IB_SUCCESS)
	{
		cout << errcode_to_str(code) << endl;
		conn.Disconnect();
		return 1;
	}

	if ((code = conn.GetResponse(pResponse)) == IB_SUCCESS)
	{
		conn.Disconnect();
		cout << "Response: " << pResponse << endl;
		cout << "Booting did not appear to be successful." << endl;
	} else {

		conn.Disconnect();
		cout << "Disconnected. Please wait patiently until it has rebooted to the SpringBoard." << endl;
		cout << "If you get repeating 'bsd root' messages, it means the ramdisk somehow got corrupted in memory before it could be loaded. Just reboot into recovery mode and try again." << endl;
	}

	releaseOutput(&ipswContents);
	releaseDictionary(info);
	free(bundlePath);

	return 0;
}
