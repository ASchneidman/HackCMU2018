734
47, 72, 73, 101, 107, 114, 119, 120, 122, 126, 130, 134, 139, 144, 149, 154, 160, 162, 163, 164, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 188, 196, 204, 209, 210, 211, 214, 218, 220, 221, 221, 222, 226, 227, 228, 232, 237, 242, 244, 246, 247, 249, 249, 250, 253, 253, 259, 261, 263, 264, 264, 265, 266, 267, 268, 273, 274, 275, 280, 281, 282, 285, 289, 290, 290, 291, 295, 296, 296, 297, 298, 298, 299, 300, 300, 301, 302, 302, 304, 309, 312, 321, 321, 325, 329, 334, 335, 340, 345, 349, 349, 353, 355, 356, 357, 357, 359, 360, 362, 363, 365, 368, 370, 370, 371, 373, 374, 375, 376, 377, 377, 378, 381, 384, 385, 387, 388, 390, 391, 392, 398, 401, 403, 404, 405, 405, 406, 407, 407, 408, 409, 409, 410, 411, 411, 412, 416, 417, 418, 420, 420, 422, 423, 424, 426, 426, 429, 430, 433, 435, 437, 453, 457, 458, 460, 462, 465, 465, 470, 471, 472, 472, 476, 478, 482, 482, 483, 484, 487, 492, 494, 495, 496, 498, 499, 501, 502, 502, 504, 504, 504, 505, 506, 507, 509, 509, 510, 512, 512, 513, 517, 517, 520, 520, 521, 522, 522, 525, 530, 530, 535, 535, 1, 2, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536
/*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 *
 */
/*
    File:       QTSSAccessModule.cpp

    Contains:   Implementation of QTSSAccessModule. 
                    
    

*/

#include "QTSSAccessModule.h"

#include "defaultPaths.h"


#include "OSArrayObjectDeleter.h"
#include "QTSS_Private.h"
#include "StrPtrLen.h"
#include "OSMemory.h"
#include "MyAssert.h"
#include "StringFormatter.h"
#include "StrPtrLen.h"
#include "StringParser.h"
#include "base64.h"
#include "OS.h"
#include "AccessChecker.h"
#include "QTAccessFile.h"
#include "QTSSModuleUtils.h"

#ifndef __Win32__
#include <unistd.h>
#endif

#include <fcntl.h>
#include <errno.h>



// ATTRIBUTES

// STATIC DATA


#define MODPREFIX_ "modAccess_"

static StrPtrLen    sSDPSuffix(".sdp");
static OSMutex*     sUserMutex              = NULL;

//static Bool16         sDefaultAuthenticationEnabled   = true;
//static Bool16         sAuthenticationEnabled          = true;

static char* sDefaultUsersFilePath  = DEFAULTPATHS_ETC_DIR "qtusers";
static char* sUsersFilePath = NULL;

static char* sDefaultGroupsFilePath = DEFAULTPATHS_ETC_DIR "qtgroups";
static char* sGroupsFilePath = NULL;

static char* sDefaultAccessFileName = "qtaccess";

static QTSS_AttributeID sBadNameMessageAttrID               = qtssIllegalAttrID;
static QTSS_AttributeID sUsersFileNotFoundMessageAttrID     = qtssIllegalAttrID;
static QTSS_AttributeID sGroupsFileNotFoundMessageAttrID    = qtssIllegalAttrID;
static QTSS_AttributeID sBadUsersFileMessageAttrID          = qtssIllegalAttrID;
static QTSS_AttributeID sBadGroupsFileMessageAttrID         = qtssIllegalAttrID;

static QTSS_StreamRef           sErrorLogStream = NULL;
static QTSS_TextMessagesObject  sMessages = NULL;
static QTSS_ModulePrefsObject   sPrefs = NULL;
static QTSS_PrefsObject         sServerPrefs = NULL;

static AccessChecker**          sAccessCheckers;
static UInt32                   sNumAccessCheckers = 0;
static UInt32                   sAccessCheckerArraySize = 0;


// FUNCTION PROTOTYPES

static QTSS_Error QTSSAccessModuleDispatch(QTSS_Role inRole, QTSS_RoleParamPtr inParams);
static QTSS_Error Register();
static QTSS_Error Initialize(QTSS_Initialize_Params* inParams);
static QTSS_Error Shutdown();
static QTSS_Error RereadPrefs();
static QTSS_Error AuthenticateRTSPRequest(QTSS_RTSPAuth_Params* inParams);
static QTSS_Error AccessAuthorizeRTSPRequest(QTSS_StandardRTSP_Params* inParams);
static char*      GetCheckedFileName();

// FUNCTION IMPLEMENTATIONS


QTSS_Error QTSSAccessModule_Main(void* inPrivateArgs)
{
    return _stublibrary_main(inPrivateArgs, QTSSAccessModuleDispatch);
}


QTSS_Error  QTSSAccessModuleDispatch(QTSS_Role inRole, QTSS_RoleParamPtr inParams)
{
    switch (inRole)
    {
        case QTSS_Register_Role:
            return Register();
        break;
        
        case QTSS_Initialize_Role:
            return Initialize(&inParams->initParams);
        break;
        
        case QTSS_RereadPrefs_Role:
            return RereadPrefs();
        break;
        
        case QTSS_RTSPAuthenticate_Role:
//          if (sAuthenticationEnabled)
                return AuthenticateRTSPRequest(&inParams->rtspAthnParams);
        break;
        
        case QTSS_RTSPAuthorize_Role:
//          if (sAuthenticationEnabled)
                return AccessAuthorizeRTSPRequest(&inParams->rtspRequestParams);
        break;
            
        case QTSS_Shutdown_Role:
            return Shutdown();
        break;
    }
    
    return QTSS_NoErr;
}

QTSS_Error Register()
{
    // Do role & attribute setup
    (void)QTSS_AddRole(QTSS_Initialize_Role);
    (void)QTSS_AddRole(QTSS_RereadPrefs_Role);
    (void)QTSS_AddRole(QTSS_RTSPAuthenticate_Role);
    (void)QTSS_AddRole(QTSS_RTSPAuthorize_Role);
        
    // Add AuthenticateName and Password attributes
    static char*        sBadAccessFileName  = "QTSSAccessModuleBadAccessFileName";
    static char*        sUsersFileNotFound  = "QTSSAccessModuleUsersFileNotFound";
    static char*        sGroupsFileNotFound = "QTSSAccessModuleGroupsFileNotFound";
    static char*        sBadUsersFile       = "QTSSAccessModuleBadUsersFile";
    static char*        sBadGroupsFile      = "QTSSAccessModuleBadGroupsFile";
    
    (void)QTSS_AddStaticAttribute(qtssTextMessagesObjectType, sBadAccessFileName, NULL, qtssAttrDataTypeCharArray);
    (void)QTSS_IDForAttr(qtssTextMessagesObjectType, sBadAccessFileName, &sBadNameMessageAttrID);
    
    (void)QTSS_AddStaticAttribute(qtssTextMessagesObjectType, sUsersFileNotFound, NULL, qtssAttrDataTypeCharArray);
    (void)QTSS_IDForAttr(qtssTextMessagesObjectType, sUsersFileNotFound, &sUsersFileNotFoundMessageAttrID);
    
    (void)QTSS_AddStaticAttribute(qtssTextMessagesObjectType, sGroupsFileNotFound, NULL, qtssAttrDataTypeCharArray);
    (void)QTSS_IDForAttr(qtssTextMessagesObjectType, sGroupsFileNotFound, &sGroupsFileNotFoundMessageAttrID);
    
    (void)QTSS_AddStaticAttribute(qtssTextMessagesObjectType, sBadUsersFile, NULL, qtssAttrDataTypeCharArray);
    (void)QTSS_IDForAttr(qtssTextMessagesObjectType, sBadUsersFile, &sBadUsersFileMessageAttrID);
    
    (void)QTSS_AddStaticAttribute(qtssTextMessagesObjectType, sBadGroupsFile, NULL, qtssAttrDataTypeCharArray);
    (void)QTSS_IDForAttr(qtssTextMessagesObjectType, sBadGroupsFile, &sBadGroupsFileMessageAttrID);
    
    return QTSS_NoErr;
}


QTSS_Error Initialize(QTSS_Initialize_Params* inParams)
{
    // Create an array of AccessCheckers
    sAccessCheckers = NEW AccessChecker*[2];
    sAccessCheckers[0] = NEW AccessChecker();
    sNumAccessCheckers = 1;
    sAccessCheckerArraySize = 2;

    // Setup module utils
    QTSSModuleUtils::Initialize(inParams->inMessages, inParams->inServer, inParams->inErrorLogStream);
    sErrorLogStream = inParams->inErrorLogStream;
    sMessages = inParams->inMessages;
    sPrefs = QTSSModuleUtils::GetModulePrefsObject(inParams->inModule);
    sServerPrefs = inParams->inPrefs;
    sUserMutex = NEW OSMutex();
    RereadPrefs();
    QTAccessFile::Initialize();
    
    return QTSS_NoErr;
}

QTSS_Error Shutdown()
{
    //cleanup
    
    // delete all the AccessCheckers
    UInt32 index;
    for(index = 0; index < sNumAccessCheckers; index++)
        delete sAccessCheckers[index];
    delete[] sAccessCheckers;
    sNumAccessCheckers = 0;
    
    // delete the main users and groups path
    
    //if(sUsersFilePath != sDefaultUsersFilePath) 
    // sUsersFilePath is assigned by a call to QTSSModuleUtils::GetStringAttribute which always
    // allocates memory even if it just returns the default value
    delete[] sUsersFilePath;
    sUsersFilePath = NULL;
    
    //if(sGroupsFilePath != sDefaultGroupsFilePath)
    // sGroupsFilePath is assigned by a call to QTSSModuleUtils::GetStringAttribute which always
    // allocates memory even if it just returns the default value
    delete[] sGroupsFilePath;
    sGroupsFilePath = NULL;
    
    return QTSS_NoErr;
}

char* GetCheckedFileName()
{
    char        *result = NULL;
    static char *badChars = "/'\"";
    char        theBadCharMessage[] = "' '";
    char        *theBadChar = NULL;
    result = QTSSModuleUtils::GetStringAttribute(sPrefs, MODPREFIX_"qtaccessfilename", sDefaultAccessFileName);
    StrPtrLen searchStr(result);
    
    theBadChar = strpbrk(searchStr.Ptr, badChars);
    if ( theBadChar!= NULL) 
    {
        theBadCharMessage[1] = theBadChar[0];
        QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadNameMessageAttrID, 0, theBadCharMessage, result);
                
        delete[] result;
        result = NEW char[::strlen(sDefaultAccessFileName) + 2];
        ::strcpy(result, sDefaultAccessFileName);   
    }
    return result;
}

QTSS_Error RereadPrefs()
{
    OSMutexLocker locker(sUserMutex);
    
    //
    // Use the standard GetAttribute routine to retrieve the correct values for our preferences
    //QTSSModuleUtils::GetAttribute(sPrefs, MODPREFIX_"enabled",    qtssAttrDataTypeBool16,
    //                      &sAuthenticationEnabled, &sDefaultAuthenticationEnabled, sizeof(sAuthenticationEnabled));
    
    //if(sUsersFilePath != sDefaultUsersFilePath)
    // sUsersFilePath is assigned by a call to QTSSModuleUtils::GetStringAttribute which always
    // allocates memory even if it just returns the default value
    // delete this old memory before reassigning it to new memory
    delete[] sUsersFilePath;
    sUsersFilePath = NULL;
        
    //if(sGroupsFilePath != sDefaultGroupsFilePath)
    // sGroupsFilePath is assigned by a call to QTSSModuleUtils::GetStringAttribute which always
    // allocates memory even if it just returns the default value
    // delete this old memory before reassigning it to new memory
    delete[] sGroupsFilePath;
    sGroupsFilePath = NULL;
    
    sUsersFilePath = QTSSModuleUtils::GetStringAttribute(sPrefs, MODPREFIX_"usersfilepath", sDefaultUsersFilePath);
    sGroupsFilePath = QTSSModuleUtils::GetStringAttribute(sPrefs, MODPREFIX_"groupsfilepath", sDefaultGroupsFilePath);
    // GetCheckedFileName always allocates memory
    char* accessFile = GetCheckedFileName();
    // QTAccessFile::SetAccessFileName makes its own copy, 
    // so delete the previous allocated memory after this call
    QTAccessFile::SetAccessFileName(accessFile);
    delete [] accessFile;
    
    if(sAccessCheckers[0]->HaveFilePathsChanged(sUsersFilePath, sGroupsFilePath))
    {
        sAccessCheckers[0]->UpdateFilePaths(sUsersFilePath, sGroupsFilePath);
        UInt32 err;
        err = sAccessCheckers[0]->UpdateUserProfiles();
        if(err & AccessChecker::kUsersFileNotFoundErr)
            QTSSModuleUtils::LogError(qtssWarningVerbosity,sUsersFileNotFoundMessageAttrID, 0, sUsersFilePath, NULL);
        else if(err & AccessChecker::kBadUsersFileErr)
            QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadUsersFileMessageAttrID, 0, sUsersFilePath, NULL);
        if(err & AccessChecker::kGroupsFileNotFoundErr)
            QTSSModuleUtils::LogError(qtssWarningVerbosity,sGroupsFileNotFoundMessageAttrID, 0, sGroupsFilePath, NULL);
        else if(err & AccessChecker::kBadGroupsFileErr)
            QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadGroupsFileMessageAttrID, 0, sGroupsFilePath, NULL);
    }
    
    return QTSS_NoErr;
}

QTSS_Error AuthenticateRTSPRequest(QTSS_RTSPAuth_Params* inParams)
{
    QTSS_RTSPRequestObject  theRTSPRequest = inParams->inRTSPRequest;
    UInt32 fileErr;
    
    OSMutexLocker locker(sUserMutex);

    if  ( (NULL == inParams) || (NULL == inParams->inRTSPRequest) )
        return QTSS_RequestFailed;

    // Get the user profile object from the request object
    QTSS_UserProfileObject theUserProfile = NULL;
    UInt32 len = sizeof(QTSS_UserProfileObject);
    QTSS_Error theErr = QTSS_GetValue(theRTSPRequest, qtssRTSPReqUserProfile, 0, (void*)&theUserProfile, &len);
    Assert(len == sizeof(QTSS_UserProfileObject));
    if (theErr != QTSS_NoErr)
        return theErr;
        
    Bool16 defaultPaths = true;
    // Check for a users and groups file in the access file
    // For this, first get local file path and root movie directory
    //get the local file path
    char*   pathBuffStr = QTSSModuleUtils::GetLocalPath_Copy(theRTSPRequest);
    OSCharArrayDeleter pathBuffDeleter(pathBuffStr);
    if (NULL == pathBuffStr)
        return QTSS_RequestFailed;
    //get the root movie directory
    char*   movieRootDirStr = QTSSModuleUtils::GetMoviesRootDir_Copy(theRTSPRequest);
    OSCharArrayDeleter movieRootDeleter(movieRootDirStr);
    if (NULL == movieRootDirStr)
        return QTSS_RequestFailed;
    // Now get the access file path
    char* accessFilePath = QTAccessFile::GetAccessFile_Copy(movieRootDirStr, pathBuffStr);
    OSCharArrayDeleter accessFilePathDeleter(accessFilePath);
    // Parse the access file for the AuthUserFile and AuthGroupFile keywords
    char* usersFilePath = NULL;
    char* groupsFilePath = NULL;
        
        // Get the request action from the request object
        QTSS_ActionFlags action = qtssActionFlagsNoFlags;
        len = sizeof(action);
        theErr = QTSS_GetValue(theRTSPRequest, qtssRTSPReqAction, 0, (void*)&action, &len);
        Assert(len == sizeof(action));
        if (theErr != QTSS_NoErr)
            return theErr;
        
    // Allocates memory for usersFilePath and groupsFilePath
    QTSS_AuthScheme authScheme = QTAccessFile::FindUsersAndGroupsFilesAndAuthScheme(accessFilePath, action, &usersFilePath, &groupsFilePath);
    
    if((usersFilePath != NULL) || (groupsFilePath != NULL)) 
        defaultPaths = false;
        
    if(usersFilePath == NULL)
        usersFilePath = sUsersFilePath;
        
    if(groupsFilePath == NULL)
        groupsFilePath = sGroupsFilePath;
        
    AccessChecker* currentChecker = NULL;
    UInt32 index;
    
    // If the default users and groups file are not the ones we need
    if(!defaultPaths) 
    {
        // check if there is one AccessChecker that matches the needed paths
        // Don't have to check for the first one (or element zero) because it has the default paths
        for(index = 1; index < sNumAccessCheckers; index++)
        {
            // If an access checker that matches the users and groups file paths is found
            if(!sAccessCheckers[index]->HaveFilePathsChanged(usersFilePath, groupsFilePath))
            {
                currentChecker = sAccessCheckers[index];
                break;
            }                       
        }
        // If an existing AccessChecker for the needed paths isn't found
        if(currentChecker == NULL)
        {
            // Grow the AccessChecker array if needed
            if(sNumAccessCheckers == sAccessCheckerArraySize)
            {
                AccessChecker** oldAccessCheckers = sAccessCheckers;
                sAccessCheckers = NEW AccessChecker*[sAccessCheckerArraySize * 2];
                for(index = 0; index < sNumAccessCheckers; index++)
                {
                    sAccessCheckers[index] = oldAccessCheckers[index];
                }
                sAccessCheckerArraySize *= 2;
                delete [] oldAccessCheckers;
            }
        
            // And create a new AccessChecker for the paths
            sAccessCheckers[sNumAccessCheckers] = NEW AccessChecker();
            sAccessCheckers[sNumAccessCheckers]->UpdateFilePaths(usersFilePath, groupsFilePath);
            fileErr = sAccessCheckers[sNumAccessCheckers]->UpdateUserProfiles();
            
            if(fileErr & AccessChecker::kUsersFileNotFoundErr)
                QTSSModuleUtils::LogError(qtssWarningVerbosity,sUsersFileNotFoundMessageAttrID, 0, usersFilePath, NULL);
            else if(fileErr & AccessChecker::kBadUsersFileErr)
                QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadUsersFileMessageAttrID, 0, usersFilePath, NULL);
            if(fileErr & AccessChecker::kGroupsFileNotFoundErr)
                QTSSModuleUtils::LogError(qtssWarningVerbosity,sGroupsFileNotFoundMessageAttrID, 0, groupsFilePath, NULL);
            else if(fileErr & AccessChecker::kBadGroupsFileErr)
                QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadGroupsFileMessageAttrID, 0, groupsFilePath, NULL);
                
            currentChecker = sAccessCheckers[sNumAccessCheckers];
            sNumAccessCheckers++;
        }
        
        // If the usersFilePath is the same as the main users file path, no new memory is allocated
        // because QTAccessFile::FindUsersAndGroupsFilesAndAuthScheme returned NULL, and we just copied the pointer
        // Otherwise, delete the memory allocated
        if(strcmp(usersFilePath, sUsersFilePath) != 0)  
            delete usersFilePath;
        
        // If the groupsFilePath is the same as the main groups file path, no new memory is allocated
        // because QTAccessFile::FindUsersAndGroupsFilesAndAuthScheme returned NULL, and we just copied the pointer
        // Otherwise, delete the memory allocated
        if(strcmp(groupsFilePath, sGroupsFilePath) != 0)    
            delete groupsFilePath;
    }
    else
    {
        currentChecker = sAccessCheckers[0];
    }
    
    // Before retrieving the user profile information
    // check if the groups/users files have been modified and update them otherwise
    fileErr = currentChecker->UpdateUserProfiles();
    
    /*
    // This is for logging the errors if users file and/or the groups file is not found or corrupted
    char* usersFile = currentChecker->GetUsersFilePathPtr();
    char* groupsFile = currentChecker->GetGroupsFilePathPtr();
    
    if(fileErr & AccessChecker::kUsersFileNotFoundErr)
        QTSSModuleUtils::LogError(qtssWarningVerbosity,sUsersFileNotFoundMessageAttrID, 0, usersFile, NULL);
    else if(fileErr & AccessChecker::kBadUsersFileErr)
        QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadUsersFileMessageAttrID, 0, usersFile, NULL);
    if(fileErr & AccessChecker::kGroupsFileNotFoundErr)
        QTSSModuleUtils::LogError(qtssWarningVerbosity,sGroupsFileNotFoundMessageAttrID, 0, groupsFile, NULL);
    else if(fileErr & AccessChecker::kBadGroupsFileErr)
        QTSSModuleUtils::LogError(qtssWarningVerbosity,sBadGroupsFileMessageAttrID, 0, groupsFile, NULL);
      */

    // Retrieve the password data and group information for the user and set them
    // in the qtssRTSPReqUserProfile attr
    // The password data is crypt of the real password for Basic authentication
    // and it is MD5(username:realm:password) for Digest authentication
    
        // It the access file didn't contain an auth scheme, then get the auth scheme out of the request object
        // else, set the qtssRTSPReqAuthScheme to that found in the access file
        
        if (authScheme == qtssAuthNone)
        {
            // Get the authentication scheme from the request object
            len = sizeof(authScheme);
            theErr = QTSS_GetValue(theRTSPRequest, qtssRTSPReqAuthScheme, 0, (void*)&authScheme, &len);
            Assert(len == sizeof(authScheme));
            if (theErr != QTSS_NoErr)
        return theErr;
    }
        else
        {
            theErr = QTSS_SetValue(theRTSPRequest, qtssRTSPReqAuthScheme, 0, (void*)&authScheme, sizeof(authScheme));
            if (theErr != QTSS_NoErr)
        return theErr;
        }
        
    // Set the qtssUserRealm to the realm value retrieved from the users file
    // This should be used for digest auth scheme, and if no realm is found in the qtaccess file, then
    // it should be used for basic auth scheme.
    // No memory is allocated; just a pointer is returned
    StrPtrLen* authRealm = currentChecker->GetAuthRealm();
    (void)QTSS_SetValue(theUserProfile, qtssUserRealm, 0, (void*)(authRealm->Ptr), (authRealm->Len));
    
    
    // Get the username from the user profile object
    char*   usernameBuf = NULL;
    theErr = QTSS_GetValueAsString(theUserProfile, qtssUserName, 0, &usernameBuf);
    OSCharArrayDeleter usernameBufDeleter(usernameBuf);
    StrPtrLen username(usernameBuf);
    if (theErr != QTSS_NoErr)
        return theErr;
    
    // No memory is allocated; just a pointer to the profile is returned
    AccessChecker::UserProfile* profile = currentChecker->RetrieveUserProfile(&username);
    
    if(profile == NULL)
        return QTSS_NoErr;
        
    // Set the qtssUserPassword attribute to either the crypted password or the digest password
    // based on the authentication scheme
    if (authScheme == qtssAuthBasic) 
        (void)QTSS_SetValue(theUserProfile, qtssUserPassword, 0, (void*)((profile->cryptPassword).Ptr), (profile->cryptPassword).Len);
    else if (authScheme == qtssAuthDigest)
        (void)QTSS_SetValue(theUserProfile, qtssUserPassword, 0, (void*)((profile->digestPassword).Ptr), (profile->digestPassword).Len);    
    
    
    // Set the multivalued qtssUserGroups attr to the groups the user belongs to, if any
    UInt32 maxLen = profile->maxGroupNameLen;
    for(index = 0; index < profile->numGroups; index++) 
    {
        UInt32 curLen = ::strlen(profile->groups[index]);
        if(curLen < maxLen) 
        {
            char* groupWithPaddedZeros = NEW char[maxLen];  // memory allocated
            ::memcpy(groupWithPaddedZeros, profile->groups[index], curLen);
            ::memset(groupWithPaddedZeros+curLen, '\0', maxLen-curLen);
            (void)QTSS_SetValue(theUserProfile, qtssUserGroups, index, (void*)groupWithPaddedZeros, maxLen);
            delete [] groupWithPaddedZeros;                 // memory deleted
        }
        else 
        {
            (void)QTSS_SetValue(theUserProfile, qtssUserGroups, index, (void*)(profile->groups[index]), maxLen);
        }
    }
    
    return QTSS_NoErr;
}

QTSS_Error AccessAuthorizeRTSPRequest(QTSS_StandardRTSP_Params* inParams)
{   
    Bool16 allowNoAccessFiles = true;
    QTSS_ActionFlags noAction = qtssActionFlagsWrite;
    QTSS_ActionFlags authorizeAction = qtssActionFlagsRead;

    return  QTAccessFile::AuthorizeRequest(inParams,allowNoAccessFiles, noAction, authorizeAction);
}
