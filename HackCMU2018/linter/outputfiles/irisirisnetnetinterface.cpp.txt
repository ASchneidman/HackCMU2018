456
21, 23, 24, 32, 33, 34, 35, 37, 38, 39, 41, 42, 42, 42, 43, 44, 45, 46, 47, 47, 47, 48, 49, 50, 51, 52, 53, 53, 54, 55, 57, 58, 58, 58, 59, 60, 61, 63, 64, 64, 64, 65, 66, 68, 69, 69, 69, 70, 71, 72, 74, 75, 75, 75, 76, 77, 78, 80, 81, 83, 84, 85, 85, 85, 86, 86, 87, 88, 89, 90, 91, 93, 94, 94, 95, 95, 96, 97, 98, 98, 98, 99, 100, 101, 102, 103, 109, 110, 111, 112, 113, 114, 116, 116, 117, 117, 117, 118, 119, 121, 122, 122, 122, 123, 124, 126, 127, 127, 127, 128, 129, 130, 131, 132, 134, 135, 135, 135, 136, 136, 137, 138, 139, 140, 141, 142, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, 159, 159, 160, 162, 163, 163, 164, 168, 169, 170, 171, 173, 173, 174, 174, 174, 175, 177, 178, 178, 178, 179, 180, 182, 183, 183, 183, 184, 185, 186, 188, 189, 189, 190, 191, 198, 199, 200, 201, 203, 205, 206, 207, 208, 209, 211, 211, 212, 212, 212, 213, 214, 216, 217, 217, 218, 219, 220, 221, 226, 227, 228, 230, 230, 231, 232, 232, 232, 233, 234, 235, 236, 237, 238, 239, 243, 244, 245, 249, 250, 254, 255, 259, 260, 264, 265, 269, 270, 282, 283, 284, 285, 287, 288, 288, 288, 289, 290, 291, 293, 294, 294, 294, 295, 297, 298, 299, 299, 299, 300, 301, 301, 301, 302, 303, 304, 305, 306, 307, 309, 310, 311, 311, 312, 313, 314, 315, 315, 316, 317, 318, 319, 323, 324, 325, 326, 328, 329, 330, 331, 333, 333, 334, 334, 334, 335, 336, 338, 338, 339, 339, 339, 340, 341, 341, 341, 342, 343, 344, 345, 346, 348, 348, 349, 349, 349, 350, 351, 351, 352, 353, 354, 356, 357, 357, 357, 358, 359, 359, 361, 363, 364, 365, 365, 365, 366, 367, 368, 369, 369, 369, 370, 371, 372, 372, 372, 373, 374, 375, 376, 377, 378, 378, 379, 380, 382, 383, 384, 384, 384, 385, 386, 387, 388, 389, 391, 392, 393, 393, 393, 394, 395, 396, 397, 398, 399, 400, 400, 400, 401, 402, 403, 404, 406, 407, 408, 409, 411, 412, 413, 413, 413, 414, 415, 416, 416, 416, 417, 418, 419, 420, 422, 423, 423, 424, 425, 426, 428, 429, 434, 435, 436, 437, 439, 440, 441, 441, 445, 446, 447, 448, 449, 450, 450, 450, 451, 452, 453, 457, 458, 459, 460, 461, 462, 466, 467, 468, 469, 470, 470, 470, 471, 472, 473, 474, 475, 479, 480, 481, 481, 481, 482, 483, 483, 483, 484, 485, 486, 487, 488, 492, 493, 496
/*
 * Copyright (C) 2006  Justin Karneges
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301  USA
 *
 */

#include "netinterface.h"

#include "irisnetplugin.h"
#include "irisnetglobal_p.h"

namespace XMPP {

//----------------------------------------------------------------------------
// NetTracker
//----------------------------------------------------------------------------
class NetTracker : public QObject
{
	Q_OBJECT
public:
	static NetTracker *self;

	NetInterfaceProvider *c;
	QList<NetInterfaceProvider::Info> info;
	QMutex m;

	NetTracker()
	{
		self = this;
		QList<IrisNetProvider*> list = irisNetProviders();
		c = 0;
		for(int n = 0; n < list.count(); ++n)
		{
			IrisNetProvider *p = list[n];
			c = p->createNetInterfaceProvider();
			if(c)
				break;
		}
		Q_ASSERT(c); // we have built-in support, so this should never fail
		connect(c, SIGNAL(updated()), SLOT(c_updated()));
	}

	~NetTracker()
	{
		delete c;
		self = 0;
	}

	static NetTracker *instance()
	{
		return self;
	}

	void start()
	{
		c->start();
		info = filterList(c->interfaces());
	}

	QList<NetInterfaceProvider::Info> getInterfaces()
	{
		QMutexLocker locker(&m);
		return info;
	}

signals:
	void updated();

public slots:
	void c_updated()
	{
		{
			QMutexLocker locker(&m);
			info = filterList(c->interfaces());
		}
		emit updated();
	}

private:
	static QList<NetInterfaceProvider::Info> filterList(const QList<NetInterfaceProvider::Info> &in)
	{
		QList<NetInterfaceProvider::Info> out;
		for(int n = 0; n < in.count(); ++n)
		{
			if(!in[n].isLoopback)
				out += in[n];
		}
		return out;
	}
};

NetTracker *NetTracker::self = 0;

class SyncThread : public QThread
{
	Q_OBJECT
public:
	QMutex control_mutex;
	QWaitCondition control_wait;
	QEventLoop *loop;

	SyncThread(QObject *parent = 0) : QThread(parent)
	{
		loop = 0;
	}

	~SyncThread()
	{
		stop();
	}

	void start()
	{
		control_mutex.lock();
		QThread::start();
		control_wait.wait(&control_mutex);
		control_mutex.unlock();
	}

	void stop()
	{
		{
			QMutexLocker locker(&control_mutex);
			if(loop)
				QMetaObject::invokeMethod(loop, "quit");
		}
		wait();
	}

	virtual void run()
	{
		control_mutex.lock();
		loop = new QEventLoop;
		begin();
		control_wait.wakeOne();
		control_mutex.unlock();
		loop->exec();
		QMutexLocker locker(&control_mutex);
		end();
		delete loop;
		loop = 0;
	}

	virtual void begin()
	{
	}

	virtual void end()
	{
	}
};

class NetThread : public SyncThread
{
	Q_OBJECT
public:
	NetTracker *tracker;

	NetThread(QObject *parent = 0) : SyncThread(parent)
	{
	}

	~NetThread()
	{
		stop();
	}

	virtual void begin()
	{
		tracker = new NetTracker;
		tracker->start();
	}

	virtual void end()
	{
		delete tracker;
	}
};

//----------------------------------------------------------------------------
// NetInterface
//----------------------------------------------------------------------------
class NetInterfacePrivate : public QObject
{
	Q_OBJECT
public:
	friend class NetInterfaceManagerPrivate;

	NetInterface *q;

	NetInterfaceManager *man;
	bool valid;
	QString id, name;
	QList<QHostAddress> addrs;
	QHostAddress gw;

	NetInterfacePrivate(NetInterface *_q) : QObject(_q), q(_q)
	{
		valid = false;
	}

	void doUnavailable()
	{
		man->unreg(q);
		valid = false;
		emit q->unavailable();
	}
};

NetInterface::NetInterface(const QString &id, NetInterfaceManager *manager)
:QObject(manager)
{
	d = new NetInterfacePrivate(this);
	d->man = manager;

	NetInterfaceProvider::Info *info = (NetInterfaceProvider::Info *)d->man->reg(id, this);
	if(info)
	{
		d->valid = true;
		d->id = info->id;
		d->name = info->name;
		d->addrs = info->addresses;
		d->gw = info->gateway;
		delete info;
	}
}

NetInterface::~NetInterface()
{
	d->man->unreg(this);
	delete d;
}

bool NetInterface::isValid() const
{
	return d->valid;
}

QString NetInterface::id() const
{
	return d->id;
}

QString NetInterface::name() const
{
	return d->name;
}

QList<QHostAddress> NetInterface::addresses() const
{
	return d->addrs;
}

QHostAddress NetInterface::gateway() const
{
	return d->gw;
}

//----------------------------------------------------------------------------
// NetInterfaceManager
//----------------------------------------------------------------------------
class NetInterfaceManagerGlobal;

Q_GLOBAL_STATIC(QMutex, nim_mutex)
static NetInterfaceManagerGlobal *g_nim = 0;

class NetInterfaceManagerGlobal
{
public:
	NetThread *thread;
	int refs;

	NetInterfaceManagerGlobal()
	{
		thread = 0;
		refs = 0;
	}

	~NetInterfaceManagerGlobal()
	{
	}

	// global mutex must be locked while calling this
	void addRef()
	{
		if(refs == 0)
		{
			thread = new NetThread;
			thread->moveToThread(QCoreApplication::instance()->thread());
			thread->start();
		}
		++refs;
	}

	// global mutex must be locked while calling this
	void removeRef()
	{
		Q_ASSERT(refs > 0);
		--refs;
		if(refs == 0)
		{
			delete thread;
			thread = 0;
		}
	}
};

class NetInterfaceManagerPrivate : public QObject
{
	Q_OBJECT
public:
	NetInterfaceManager *q;

	QMutex m;
	QList<NetInterfaceProvider::Info> info;
	QList<NetInterface*> listeners;
	bool pending;

	NetInterfaceManagerPrivate(NetInterfaceManager *_q) : q(_q)
	{
		pending = false;
	}

	static int lookup(const QList<NetInterfaceProvider::Info> &list, const QString &id)
	{
		for(int n = 0; n < list.count(); ++n)
		{
			if(list[n].id == id)
				return n;
		}
		return -1;
	}

	static bool sameContent(const NetInterfaceProvider::Info &a, const NetInterfaceProvider::Info &b)
	{
		// assume ids are the same already
		if(a.name == b.name && a.isLoopback == b.isLoopback && a.addresses == b.addresses && a.gateway == b.gateway)
			return true;
		return false;
	}

	void do_update()
	{
		// grab the latest info
		QList<NetInterfaceProvider::Info> newinfo = NetTracker::instance()->getInterfaces();

		QStringList here_ids, gone_ids;

		// removed / changed
		for(int n = 0; n < info.count(); ++n)
		{
			int i = lookup(newinfo, info[n].id);
			// id is still here
			if(i != -1)
			{
				// content changed?
				if(!sameContent(info[n], newinfo[i]))
				{
					gone_ids += info[n].id;
					here_ids += info[n].id;
				}
			}
			// id is gone
			else
				gone_ids += info[n].id;
		}

		// added
		for(int n = 0; n < newinfo.count(); ++n)
		{
			int i = lookup(info, newinfo[n].id);
			if(i == -1)
				here_ids += newinfo[n].id;
		}
		info = newinfo;

		// announce gone
		for(int n = 0; n < gone_ids.count(); ++n)
		{
			// work on a copy, just in case the list changes.
			//   it is important to make the copy here, and not
			//   outside the outer loop, in case the items
			//   get deleted
			QList<NetInterface*> list = listeners;
			for(int i = 0; i < list.count(); ++i)
			{
				if(list[i]->d->id == gone_ids[n])
					list[i]->d->doUnavailable();
			}
		}

		// announce here
		for(int n = 0; n < here_ids.count(); ++n)
			emit q->interfaceAvailable(here_ids[n]);
	}

public slots:
	void tracker_updated()
	{
		QMutexLocker locker(&m);
		if(!pending)
		{
			QMetaObject::invokeMethod(this, "update", Qt::QueuedConnection);
			pending = true;
		}
	}

	void update()
	{
		m.lock();
		pending = false;
		m.unlock();

		do_update();
	}
};

NetInterfaceManager::NetInterfaceManager(QObject *parent)
:QObject(parent)
{
	QMutexLocker locker(nim_mutex());
	if(!g_nim)
		g_nim = new NetInterfaceManagerGlobal;

	d = new NetInterfaceManagerPrivate(this);
	g_nim->addRef();
	d->connect(NetTracker::instance(), SIGNAL(updated()), SLOT(tracker_updated()), Qt::DirectConnection);
}

NetInterfaceManager::~NetInterfaceManager()
{
	QMutexLocker locker(nim_mutex());
	g_nim->removeRef();
	delete d;
	if(g_nim->refs == 0)
	{
		delete g_nim;
		g_nim = 0;
	}
}

QStringList NetInterfaceManager::interfaces() const
{
	d->info = NetTracker::instance()->getInterfaces();
	QStringList out;
	for(int n = 0; n < d->info.count(); ++n)
		out += d->info[n].id;
	return out;
}

QString NetInterfaceManager::interfaceForAddress(const QHostAddress &a)
{
	NetInterfaceManager netman;
	QStringList list = netman.interfaces();
	for(int n = 0; n < list.count(); ++n)
	{
		NetInterface iface(list[n], &netman);
		if(iface.addresses().contains(a))
			return list[n];
	}
	return QString();
}

void *NetInterfaceManager::reg(const QString &id, NetInterface *i)
{
	for(int n = 0; n < d->info.count(); ++n)
	{
		if(d->info[n].id == id)
		{
			d->listeners += i;
			return new NetInterfaceProvider::Info(d->info[n]);
		}
	}
	return 0;
}

void NetInterfaceManager::unreg(NetInterface *i)
{
	d->listeners.removeAll(i);
}

}

#include "netinterface.moc"
