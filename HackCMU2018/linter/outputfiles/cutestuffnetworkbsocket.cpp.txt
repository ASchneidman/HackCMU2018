320
25, 27, 29, 31, 33, 44, 45, 46, 47, 47, 48, 49, 49, 49, 50, 50, 51, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 59, 60, 61, 62, 63, 64, 65, 67, 68, 69, 69, 69, 70, 71, 73, 74, 74, 74, 75, 76, 78, 79, 79, 79, 80, 81, 83, 84, 84, 84, 85, 86, 88, 89, 89, 89, 90, 91, 93, 94, 94, 95, 96, 100, 101, 102, 103, 103, 103, 104, 105, 106, 108, 109, 110, 113, 115, 116, 117, 118, 118, 123, 124, 126, 128, 130, 134, 135, 136, 140, 141, 142, 143, 148, 149, 150, 151, 152, 154, 154, 155, 156, 157, 158, 159, 159, 159, 160, 161, 162, 164, 165, 167, 168, 170, 174, 175, 176, 178, 180, 181, 182, 183, 184, 185, 185, 186, 186, 187, 191, 192, 193, 194, 196, 197, 199, 200, 205, 206, 207, 208, 212, 213, 214, 215, 216, 220, 221, 222, 223, 224, 228, 229, 233, 234, 235, 236, 237, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 251, 251, 252, 253, 257, 258, 259, 261, 262, 264, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 277, 278, 281, 282, 284, 288, 289, 290, 291, 292, 296, 297, 298, 299, 303, 304, 305, 306, 307, 311, 312, 313, 314, 315, 319, 320, 321, 322, 323, 327, 328, 329, 330, 331, 335, 336, 338, 340, 341, 342, 344, 345, 346, 347, 347, 348, 348, 352, 354, 355, 356, 357, 358, 358, 359, 359, 360, 361, 361, 361, 363, 365, 366, 371, 373, 375, 376, 380, 381, 381, 385, 386, 388, 390, 390, 391, 395, 396, 397, 397, 397, 399, 401, 401, 402, 403, 404, 408, 409, 409, 410, 414, 415, 417, 419, 419, 420, 424, 425, 427, 429, 429, 430, 431, 432, 433, 436, 438, 438, 440, 441, 441, 442, 443, 444, 446, 447, 448, 449, 449, 450, 451, 452
/*
 * bsocket.cpp - QSocket wrapper based on Bytestream with SRV DNS support
 * Copyright (C) 2003  Justin Karneges
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include <QTcpSocket>
#include <QHostAddress>
#include <QMetaType>

#include "bsocket.h"

//#include "safedelete.h"
#ifndef NO_NDNS
#include "ndns.h"
#endif
#include "srvresolver.h"

//#define BS_DEBUG

#ifdef BS_DEBUG
#include <stdio.h>
#endif

#define READBUFSIZE 65536

// CS_NAMESPACE_BEGIN

class QTcpSocketSignalRelay : public QObject
{
	Q_OBJECT
public:
	QTcpSocketSignalRelay(QTcpSocket *sock, QObject *parent = 0)
	:QObject(parent)
	{
		qRegisterMetaType<QAbstractSocket::SocketError>("QAbstractSocket::SocketError");
		connect(sock, SIGNAL(hostFound()), SLOT(sock_hostFound()), Qt::QueuedConnection);
		connect(sock, SIGNAL(connected()), SLOT(sock_connected()), Qt::QueuedConnection);
		connect(sock, SIGNAL(disconnected()), SLOT(sock_disconnected()), Qt::QueuedConnection);
		connect(sock, SIGNAL(readyRead()), SLOT(sock_readyRead()), Qt::QueuedConnection);
		connect(sock, SIGNAL(bytesWritten(qint64)), SLOT(sock_bytesWritten(qint64)), Qt::QueuedConnection);
		connect(sock, SIGNAL(error(QAbstractSocket::SocketError)), SLOT(sock_error(QAbstractSocket::SocketError)), Qt::QueuedConnection);
	}

signals:
	void hostFound();
	void connected();
	void disconnected();
	void readyRead();
	void bytesWritten(qint64);
	void error(QAbstractSocket::SocketError);

public slots:
	void sock_hostFound()
	{
		emit hostFound();
	}

	void sock_connected()
	{
		emit connected();
	}

	void sock_disconnected()
	{
		emit disconnected();
	}

	void sock_readyRead()
	{
		emit readyRead();
	}

	void sock_bytesWritten(qint64 x)
	{
		emit bytesWritten(x);
	}

	void sock_error(QAbstractSocket::SocketError x)
	{
		emit error(x);
	}
};

class BSocket::Private
{
public:
	Private()
	{
		qsock = 0;
		qsock_relay = 0;
	}

	QTcpSocket *qsock;
	QTcpSocketSignalRelay *qsock_relay;
	int state;

#ifndef NO_NDNS
	NDns ndns;
#endif
	SrvResolver srv;
	QString host;
	int port;
	//SafeDelete sd;
};

BSocket::BSocket(QObject *parent)
:ByteStream(parent)
{
	d = new Private;
#ifndef NO_NDNS
	connect(&d->ndns, SIGNAL(resultsReady()), SLOT(ndns_done()));
#endif
	connect(&d->srv, SIGNAL(resultsReady()), SLOT(srv_done()));

	reset();
}

BSocket::~BSocket()
{
	reset(true);
	delete d;
}

void BSocket::reset(bool clear)
{
	if(d->qsock) {
		delete d->qsock_relay;
		d->qsock_relay = 0;

		/*d->qsock->disconnect(this);

		if(!clear && d->qsock->isOpen() && d->qsock->isValid()) {*/
			// move remaining into the local queue
			QByteArray block(d->qsock->bytesAvailable(), 0);
			d->qsock->read(block.data(), block.size());
			appendRead(block);
		//}

		//d->sd.deleteLater(d->qsock);
		// delete d->qsock;
		d->qsock->deleteLater();
		d->qsock = 0;
	}
	else {
		if(clear)
			clearReadBuffer();
	}

	if(d->srv.isBusy())
		d->srv.stop();
#ifndef NO_NDNS
	if(d->ndns.isBusy())
		d->ndns.stop();
#endif
	d->state = Idle;
}

void BSocket::ensureSocket()
{
	if(!d->qsock) {
		d->qsock = new QTcpSocket;
#if QT_VERSION >= 0x030200
		d->qsock->setReadBufferSize(READBUFSIZE);
#endif
		d->qsock_relay = new QTcpSocketSignalRelay(d->qsock);
		connect(d->qsock_relay, SIGNAL(hostFound()), SLOT(qs_hostFound()));
		connect(d->qsock_relay, SIGNAL(connected()), SLOT(qs_connected()));
		connect(d->qsock_relay, SIGNAL(disconnected()), SLOT(qs_closed()));
		connect(d->qsock_relay, SIGNAL(readyRead()), SLOT(qs_readyRead()));
		connect(d->qsock_relay, SIGNAL(bytesWritten(qint64)), SLOT(qs_bytesWritten(qint64)));
		connect(d->qsock_relay, SIGNAL(error(QAbstractSocket::SocketError)), SLOT(qs_error(QAbstractSocket::SocketError)));
	}
}

void BSocket::connectToHost(const QString &host, quint16 port)
{
	reset(true);
	d->host = host;
	d->port = port;
#ifdef NO_NDNS
	d->state = Connecting;
	do_connect();
#else
	d->state = HostLookup;
	d->ndns.resolve(d->host);
#endif
}

void BSocket::connectToServer(const QString &srv, const QString &type)
{
	reset(true);
	d->state = HostLookup;
	d->srv.resolve(srv, type, "tcp");
}

int BSocket::socket() const
{
	if(d->qsock)
		return d->qsock->socketDescriptor();
	else
		return -1;
}

void BSocket::setSocket(int s)
{
	reset(true);
	ensureSocket();
	d->state = Connected;
	d->qsock->setSocketDescriptor(s);
}

int BSocket::state() const
{
	return d->state;
}

bool BSocket::isOpen() const
{
	if(d->state == Connected)
		return true;
	else
		return false;
}

void BSocket::close()
{
	if(d->state == Idle)
		return;

	if(d->qsock) {
		d->qsock->close();
		d->state = Closing;
		if(d->qsock->bytesToWrite() == 0)
			reset();
	}
	else {
		reset();
	}
}

void BSocket::write(const QByteArray &a)
{
	if(d->state != Connected)
		return;
#ifdef BS_DEBUG
	QString s = QString::fromUtf8(a);
	fprintf(stderr, "BSocket: writing [%d]: {%s}\n", a.size(), s.latin1());
#endif
	d->qsock->write(a.data(), a.size());
}

QByteArray BSocket::read(int bytes)
{
	QByteArray block;
	if(d->qsock) {
		int max = bytesAvailable();
		if(bytes <= 0 || bytes > max)
			bytes = max;
		block.resize(bytes);
		d->qsock->read(block.data(), block.size());
	}
	else
		block = ByteStream::read(bytes);

#ifdef BS_DEBUG
	QString s = QString::fromUtf8(block);
	fprintf(stderr, "BSocket: read [%d]: {%s}\n", block.size(), s.latin1());
#endif
	return block;
}

int BSocket::bytesAvailable() const
{
	if(d->qsock)
		return d->qsock->bytesAvailable();
	else
		return ByteStream::bytesAvailable();
}

int BSocket::bytesToWrite() const
{
	if(!d->qsock)
		return 0;
	return d->qsock->bytesToWrite();
}

QHostAddress BSocket::address() const
{
	if(d->qsock)
		return d->qsock->localAddress();
	else
		return QHostAddress();
}

quint16 BSocket::port() const
{
	if(d->qsock)
		return d->qsock->localPort();
	else
		return 0;
}

QHostAddress BSocket::peerAddress() const
{
	if(d->qsock)
		return d->qsock->peerAddress();
	else
		return QHostAddress();
}

quint16 BSocket::peerPort() const
{
	if(d->qsock)
		return d->qsock->peerPort();
	else
		return 0;
}

void BSocket::srv_done()
{
	if(d->srv.failed()) {
#ifdef BS_DEBUG
		fprintf(stderr, "BSocket: Error resolving hostname.\n");
#endif
		error(ErrHostNotFound);
		return;
	}

	d->host = d->srv.resultAddress().toString();
	d->port = d->srv.resultPort();
	do_connect();
	//QTimer::singleShot(0, this, SLOT(do_connect()));
	//hostFound();
}

void BSocket::ndns_done()
{
#ifndef NO_NDNS
	if(!d->ndns.result().isNull()) {
		d->host = d->ndns.resultString();
		d->state = Connecting;
		do_connect();
		//QTimer::singleShot(0, this, SLOT(do_connect()));
		//hostFound();
	}
	else {
#ifdef BS_DEBUG
		fprintf(stderr, "BSocket: Error resolving hostname.\n");
#endif
		error(ErrHostNotFound);
	}
#endif
}

void BSocket::do_connect()
{
#ifdef BS_DEBUG
	fprintf(stderr, "BSocket: Connecting to %s:%d\n", d->host.latin1(), d->port);
#endif
	ensureSocket();
	d->qsock->connectToHost(d->host, d->port);
}

void BSocket::qs_hostFound()
{
	//SafeDeleteLock s(&d->sd);
}

void BSocket::qs_connected()
{
	d->state = Connected;
#ifdef BS_DEBUG
	fprintf(stderr, "BSocket: Connected.\n");
#endif
	//SafeDeleteLock s(&d->sd);
	connected();
}

void BSocket::qs_closed()
{
	if(d->state == Closing)
	{
#ifdef BS_DEBUG
		fprintf(stderr, "BSocket: Delayed Close Finished.\n");
#endif
		//SafeDeleteLock s(&d->sd);
		reset();
		delayedCloseFinished();
	}
}

void BSocket::qs_readyRead()
{
	//SafeDeleteLock s(&d->sd);
	readyRead();
}

void BSocket::qs_bytesWritten(qint64 x64)
{
	int x = x64;
#ifdef BS_DEBUG
	fprintf(stderr, "BSocket: BytesWritten [%d].\n", x);
#endif
	//SafeDeleteLock s(&d->sd);
	bytesWritten(x);
}

void BSocket::qs_error(QAbstractSocket::SocketError x)
{
	if(x == QTcpSocket::RemoteHostClosedError) {
#ifdef BS_DEBUG
		fprintf(stderr, "BSocket: Connection Closed.\n");
#endif
		//SafeDeleteLock s(&d->sd);
		reset();
		connectionClosed();
		return;
	}

#ifdef BS_DEBUG
	fprintf(stderr, "BSocket: Error.\n");
#endif
	//SafeDeleteLock s(&d->sd);

	// connection error during SRV host connect?  try next
	if(d->state == HostLookup && (x == QTcpSocket::ConnectionRefusedError || x == QTcpSocket::HostNotFoundError)) {
		d->srv.next();
		return;
	}

	reset();
	if(x == QTcpSocket::ConnectionRefusedError)
		error(ErrConnectionRefused);
	else if(x == QTcpSocket::HostNotFoundError)
		error(ErrHostNotFound);
	else
		error(ErrRead);
}

#include "bsocket.moc"

// CS_NAMESPACE_END
