141
20, 21, 21, 22, 22, 22, 23, 24, 24, 24, 25, 26, 28, 29, 29, 29, 30, 31, 33, 34, 34, 34, 35, 36, 38, 39, 39, 39, 40, 41, 43, 44, 44, 44, 45, 46, 48, 49, 49, 49, 50, 51, 53, 54, 54, 54, 55, 56, 58, 59, 59, 59, 60, 61, 63, 64, 64, 64, 65, 66, 68, 69, 69, 69, 70, 71, 73, 74, 74, 74, 75, 76, 78, 79, 79, 79, 80, 81, 83, 84, 84, 84, 85, 86, 88, 89, 89, 89, 90, 91, 93, 94, 94, 94, 95, 96, 98, 99, 99, 99, 100, 101, 103, 104, 104, 104, 105, 106, 108, 109, 109, 109, 110, 111, 113, 114, 114, 114, 115, 116, 118, 119, 119, 119, 120, 121, 123, 124, 124, 124, 125, 126, 128, 129, 129, 129, 130, 131, 132, 132, 133
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with main.c; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA
 */

#include "SDL4Cpp_mt.h"

namespace SDL
{
	namespace MT
	{
		Thread *CreateThread(int (*fn)(void *), void *data)
		{
			return SDL_CreateThread(fn, data);
		}

		Uint32 ThreadID(void)
		{
			return SDL_ThreadID();
		}

		Uint32 GetThreadID(Thread *thread)
		{
			return SDL_GetThreadID(thread);
		}

		void WaitThread(Thread *thread, int *status)
		{
			SDL_WaitThread(thread, status);
		}

		void KillThread(Thread *thread)
		{
			SDL_KillThread(thread);
		}

		Mutex *CreateMutex(void)
		{
			return SDL_CreateMutex();
		}

		void DestroyMutex(Mutex *mutex)
		{
			SDL_DestroyMutex(mutex);
		}

		int MutexP(Mutex *mutex)
		{
			return SDL_mutexP(mutex);
		}

		int MutexV(Mutex *mutex)
		{
			return SDL_mutexV(mutex);
		}

		Sem *CreateSemaphore(Uint32 initial_value)
		{
			return SDL_CreateSemaphore(initial_value);
		}

		void DestroySemaphore(Sem *sem)
		{
			SDL_DestroySemaphore(sem);
		}

		int SemWait(Sem *sem)
		{
			return SDL_SemWait(sem);
		}

		int SemTryWait(Sem *sem)
		{
			return SDL_SemTryWait(sem);
		}

		int SemWaitTimeout(Sem *sem, Uint32 timeout)
		{
			return SDL_SemWaitTimeout(sem, timeout);
		}

		int SemPost(Sem *sem)
		{
			return SDL_SemPost(sem);
		}

		Uint32 SemValue(Sem *sem)
		{
			return SDL_SemValue(sem);
		}

		Cond *CreateCond(void)
		{
			return SDL_CreateCond();
		}

		void DestroyCond(Cond *cond)
		{
			SDL_DestroyCond(cond);
		}

		int CondSignal(Cond *cond)
		{
			return SDL_CondSignal(cond);
		}

		int CondBroadcast(Cond *cond)
		{
			return SDL_CondBroadcast(cond);
		}

		int CondWait(Cond *cond, Mutex *mutex)
		{
			return SDL_CondWait(cond, mutex);
		}

		int CondWaitTimeout(Cond *cond, Mutex *mutex, Uint32 ms)
		{
			return SDL_CondWaitTimeout(cond, mutex, ms);
		}
	}
}

