762
9, 11, 12, 21, 21, 35, 36, 37, 37, 38, 39, 43, 44, 45, 45, 46, 47, 47, 48, 48, 52, 53, 54, 54, 55, 56, 60, 61, 62, 62, 63, 64, 68, 69, 70, 70, 71, 72, 76, 77, 78, 78, 78, 79, 83, 84, 85, 85, 85, 86, 90, 91, 92, 92, 92, 93, 97, 98, 99, 99, 100, 100, 101, 102, 106, 107, 108, 108, 109, 109, 110, 111, 115, 116, 117, 117, 118, 118, 119, 120, 124, 125, 126, 127, 127, 128, 128, 131, 132, 134, 135, 135, 136, 136, 139, 140, 142, 147, 148, 149, 149, 150, 151, 155, 156, 157, 157, 158, 159, 159, 160, 160, 164, 165, 166, 166, 167, 168, 172, 173, 174, 174, 175, 176, 180, 181, 182, 182, 183, 184, 188, 189, 190, 190, 190, 191, 195, 196, 197, 197, 197, 198, 202, 203, 204, 204, 204, 205, 209, 210, 211, 211, 212, 212, 213, 214, 218, 219, 220, 220, 221, 221, 222, 223, 227, 228, 229, 229, 230, 230, 231, 232, 236, 237, 238, 239, 239, 240, 240, 243, 244, 246, 247, 247, 248, 248, 251, 252, 254, 259, 260, 261, 263, 263, 264, 264, 268, 269, 271, 271, 278, 281, 343, 347, 350, 351, 351, 351, 352, 353, 353, 354, 357, 358, 358, 358, 359, 360, 360, 361, 362, 366, 367, 368, 369, 370, 374, 375, 376, 377, 377, 378, 378, 379, 383, 384, 384, 384, 385, 386, 386, 387, 387, 388, 392, 393, 393, 394, 395, 395, 399, 400, 400, 400, 401, 402, 402, 406, 407, 407, 407, 408, 409, 409, 413, 414, 414, 415, 416, 416, 420, 421, 421, 422, 423, 423, 428, 429, 429, 430, 431, 431, 432, 433, 435, 435, 441, 442, 443, 443, 443, 444, 444, 449, 450, 451, 451, 451, 452, 452, 457, 458, 459, 459, 459, 460, 460, 465, 466, 466, 467, 467, 468, 472, 473, 474, 474, 475, 476, 476, 477, 478, 479, 479, 479, 480, 481, 481, 482, 482, 483, 493, 494, 495, 496, 497, 498, 499, 499, 500, 500, 500, 500, 500, 501, 501, 507, 508, 509, 510, 511, 512, 513, 513, 514, 514, 514, 514, 514, 515, 515, 519, 520, 521, 522, 523, 524, 525, 526, 526, 527, 527, 527, 527, 527, 528, 528, 532, 533, 534, 535, 536, 537, 538, 539, 539, 540, 540, 540, 540, 540, 541, 541, 545, 546, 547, 548, 549, 550, 551, 552, 552, 553, 553, 553, 553, 553, 554, 554, 558, 559, 560, 561, 562, 563, 564, 565, 565, 566, 566, 566, 566, 566, 567, 567, 571, 572, 573, 574, 575, 575, 576, 576, 576, 580, 581, 582, 583, 584, 584, 585, 585, 585, 592, 593, 594, 595, 596, 597, 598, 598, 599, 599, 599, 599, 599, 600, 601, 601, 602, 602, 603, 607, 608, 609, 610, 611, 612, 613, 613, 614, 614, 614, 614, 614, 615, 616, 616, 617, 617, 618, 622, 623, 624, 625, 626, 627, 628, 628, 629, 629, 629, 629, 629, 630, 631, 631, 632, 632, 633, 637, 638, 639, 640, 641, 642, 643, 643, 644, 644, 644, 644, 644, 645, 646, 646, 647, 647, 648, 652, 653, 654, 655, 656, 657, 658, 658, 659, 659, 659, 659, 659, 660, 661, 661, 662, 662, 663, 667, 668, 669, 670, 671, 672, 673, 673, 674, 674, 674, 674, 674, 675, 676, 676, 677, 677, 678, 682, 683, 684, 685, 686, 686, 687, 688, 689, 689, 690, 690, 691, 695, 696, 697, 698, 699, 699, 700, 701, 702, 702, 703, 703, 704, 711, 712, 713, 714, 715, 719, 720, 721, 722, 723, 727, 728, 729, 729, 730, 731, 731, 732, 732, 736, 737, 738, 738, 739, 740, 740, 741, 741, 745, 746, 747, 747, 748, 749, 753, 754, 755, 755, 756, 757, 761, 762, 763, 763, 764, 765, 769, 770, 771, 771, 772, 773, 777, 778, 779, 779, 780, 781, 785, 786, 787, 787, 788, 789, 793, 794, 795, 795, 795, 796, 800, 801, 802, 802, 802, 803, 807, 808, 809, 809, 810, 814, 815, 816, 816, 817, 821, 822, 823, 823, 824, 828, 829, 830, 830, 831, 835, 836, 837, 837, 838, 838, 839, 840, 844, 845, 846, 846, 847, 847, 848, 849, 853, 854, 855, 855, 856, 856, 857, 858, 862, 863, 864, 864, 865, 865, 866, 867, 871, 872, 873, 873, 874, 874, 875, 876, 880, 881, 882, 882, 883, 883, 884, 885, 889, 890, 891, 892, 892, 893, 893, 896, 897, 899, 900, 900, 901, 901, 904, 905, 907, 911, 912, 913, 914, 914, 915, 915, 918, 919, 921, 922, 922, 923, 923, 926, 927, 929, 933
/// \ingroup newmat
///@{

/// \file newmat6.cpp
/// Operators, element access.

// Copyright (C) 1991,2,3,4: R B Davies

#include "include.h"

#include "newmat.h"
#include "newmatrc.h"

#ifdef use_namespace
namespace NEWMAT {
#endif



#ifdef DO_REPORT
#define REPORT { static ExeCounter ExeCount(__LINE__,6); ++ExeCount; }
#else
#define REPORT {}
#endif

/*************************** general utilities *************************/

static int tristore(int n)                      // els in triangular matrix
{ return (n*(n+1))/2; }


/****************************** operators *******************************/

Real& Matrix::operator()(int m, int n)
{
   REPORT
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val)
      Throw(IndexException(m,n,*this));
   return store[(m-1)*ncols_val+n-1];
}

Real& SymmetricMatrix::operator()(int m, int n)
{
   REPORT
   if (m<=0 || n<=0 || m>nrows_val || n>ncols_val)
      Throw(IndexException(m,n,*this));
   if (m>=n) return store[tristore(m-1)+n-1];
   else return store[tristore(n-1)+m-1];
}

Real& UpperTriangularMatrix::operator()(int m, int n)
{
   REPORT
   if (m<=0 || n<m || n>ncols_val)
      Throw(IndexException(m,n,*this));
   return store[(m-1)*ncols_val+n-1-tristore(m-1)];
}

Real& LowerTriangularMatrix::operator()(int m, int n)
{
   REPORT
   if (n<=0 || m<n || m>nrows_val)
      Throw(IndexException(m,n,*this));
   return store[tristore(m-1)+n-1];
}

Real& DiagonalMatrix::operator()(int m, int n)
{
   REPORT
   if (n<=0 || m!=n || m>nrows_val || n>ncols_val)
      Throw(IndexException(m,n,*this));
   return store[n-1];
}

Real& DiagonalMatrix::operator()(int m)
{
   REPORT
   if (m<=0 || m>nrows_val) Throw(IndexException(m,*this));
   return store[m-1];
}

Real& ColumnVector::operator()(int m)
{
   REPORT
   if (m<=0 || m> nrows_val) Throw(IndexException(m,*this));
   return store[m-1];
}

Real& RowVector::operator()(int n)
{
   REPORT
   if (n<=0 || n> ncols_val) Throw(IndexException(n,*this));
   return store[n-1];
}

Real& BandMatrix::operator()(int m, int n)
{
   REPORT
   int w = upper_val+lower_val+1; int i = lower_val+n-m;
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this));
   return store[w*(m-1)+i];
}

Real& UpperBandMatrix::operator()(int m, int n)
{
   REPORT
   int w = upper_val+1; int i = n-m;
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this));
   return store[w*(m-1)+i];
}

Real& LowerBandMatrix::operator()(int m, int n)
{
   REPORT
   int w = lower_val+1; int i = lower_val+n-m;
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this));
   return store[w*(m-1)+i];
}

Real& SymmetricBandMatrix::operator()(int m, int n)
{
   REPORT
   int w = lower_val+1;
   if (m>=n)
   {
      REPORT
      int i = lower_val+n-m;
      if ( m>nrows_val || n<=0 || i<0 )
         Throw(IndexException(m,n,*this));
      return store[w*(m-1)+i];
   }
   else
   {
      REPORT
      int i = lower_val+m-n;
      if ( n>nrows_val || m<=0 || i<0 )
         Throw(IndexException(m,n,*this));
      return store[w*(n-1)+i];
   }
}


Real Matrix::operator()(int m, int n) const
{
   REPORT
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val)
      Throw(IndexException(m,n,*this));
   return store[(m-1)*ncols_val+n-1];
}

Real SymmetricMatrix::operator()(int m, int n) const
{
   REPORT
   if (m<=0 || n<=0 || m>nrows_val || n>ncols_val)
      Throw(IndexException(m,n,*this));
   if (m>=n) return store[tristore(m-1)+n-1];
   else return store[tristore(n-1)+m-1];
}

Real UpperTriangularMatrix::operator()(int m, int n) const
{
   REPORT
   if (m<=0 || n<m || n>ncols_val)
      Throw(IndexException(m,n,*this));
   return store[(m-1)*ncols_val+n-1-tristore(m-1)];
}

Real LowerTriangularMatrix::operator()(int m, int n) const
{
   REPORT
   if (n<=0 || m<n || m>nrows_val)
      Throw(IndexException(m,n,*this));
   return store[tristore(m-1)+n-1];
}

Real DiagonalMatrix::operator()(int m, int n) const
{
   REPORT
   if (n<=0 || m!=n || m>nrows_val || n>ncols_val)
      Throw(IndexException(m,n,*this));
   return store[n-1];
}

Real DiagonalMatrix::operator()(int m) const
{
   REPORT
   if (m<=0 || m>nrows_val) Throw(IndexException(m,*this));
   return store[m-1];
}

Real ColumnVector::operator()(int m) const
{
   REPORT
   if (m<=0 || m> nrows_val) Throw(IndexException(m,*this));
   return store[m-1];
}

Real RowVector::operator()(int n) const
{
   REPORT
   if (n<=0 || n> ncols_val) Throw(IndexException(n,*this));
   return store[n-1];
}

Real BandMatrix::operator()(int m, int n) const
{
   REPORT
   int w = upper_val+lower_val+1; int i = lower_val+n-m;
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this));
   return store[w*(m-1)+i];
}

Real UpperBandMatrix::operator()(int m, int n) const
{
   REPORT
   int w = upper_val+1; int i = n-m;
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this));
   return store[w*(m-1)+i];
}

Real LowerBandMatrix::operator()(int m, int n) const
{
   REPORT
   int w = lower_val+1; int i = lower_val+n-m;
   if (m<=0 || m>nrows_val || n<=0 || n>ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this));
   return store[w*(m-1)+i];
}

Real SymmetricBandMatrix::operator()(int m, int n) const
{
   REPORT
   int w = lower_val+1;
   if (m>=n)
   {
      REPORT
      int i = lower_val+n-m;
      if ( m>nrows_val || n<=0 || i<0 )
         Throw(IndexException(m,n,*this));
      return store[w*(m-1)+i];
   }
   else
   {
      REPORT
      int i = lower_val+m-n;
      if ( n>nrows_val || m<=0 || i<0 )
         Throw(IndexException(m,n,*this));
      return store[w*(n-1)+i];
   }
}


Real BaseMatrix::as_scalar() const
{
   REPORT
   GeneralMatrix* gm = ((BaseMatrix&)*this).Evaluate();

   if (gm->nrows_val!=1 || gm->ncols_val!=1)
   {
      Tracer tr("as_scalar");
      Try
         { Throw(ProgramException("Cannot convert to scalar", *gm)); }
      CatchAll { gm->tDelete(); ReThrow; }
   }

   Real x = *(gm->store); gm->tDelete(); return x;
}


AddedMatrix BaseMatrix::operator+(const BaseMatrix& bm) const
{ REPORT return AddedMatrix(this, &bm); }

SPMatrix SP(const BaseMatrix& bm1,const BaseMatrix& bm2)
{ REPORT return SPMatrix(&bm1, &bm2); }

KPMatrix KP(const BaseMatrix& bm1,const BaseMatrix& bm2)
{ REPORT return KPMatrix(&bm1, &bm2); }

MultipliedMatrix BaseMatrix::operator*(const BaseMatrix& bm) const
{ REPORT return MultipliedMatrix(this, &bm); }

ConcatenatedMatrix BaseMatrix::operator|(const BaseMatrix& bm) const
{ REPORT return ConcatenatedMatrix(this, &bm); }

StackedMatrix BaseMatrix::operator&(const BaseMatrix& bm) const
{ REPORT return StackedMatrix(this, &bm); }

SolvedMatrix InvertedMatrix::operator*(const BaseMatrix& bmx) const
{ REPORT return SolvedMatrix(bm, &bmx); }

SubtractedMatrix BaseMatrix::operator-(const BaseMatrix& bm) const
{ REPORT return SubtractedMatrix(this, &bm); }

ShiftedMatrix BaseMatrix::operator+(Real f) const
{ REPORT return ShiftedMatrix(this, f); }

ShiftedMatrix operator+(Real f, const BaseMatrix& BM)
{ REPORT return ShiftedMatrix(&BM, f); }

NegShiftedMatrix operator-(Real f, const BaseMatrix& bm)
{ REPORT return NegShiftedMatrix(f, &bm); }

ScaledMatrix BaseMatrix::operator*(Real f) const
{ REPORT return ScaledMatrix(this, f); }

ScaledMatrix BaseMatrix::operator/(Real f) const
{ REPORT return ScaledMatrix(this, 1.0/f); }

ScaledMatrix operator*(Real f, const BaseMatrix& BM)
{ REPORT return ScaledMatrix(&BM, f); }

ShiftedMatrix BaseMatrix::operator-(Real f) const
{ REPORT return ShiftedMatrix(this, -f); }

TransposedMatrix BaseMatrix::t() const
{ REPORT return TransposedMatrix(this); }

NegatedMatrix BaseMatrix::operator-() const
{ REPORT return NegatedMatrix(this); }

ReversedMatrix BaseMatrix::reverse() const
{ REPORT return ReversedMatrix(this); }

InvertedMatrix BaseMatrix::i() const
{ REPORT return InvertedMatrix(this); }


RowedMatrix BaseMatrix::as_row() const
{ REPORT return RowedMatrix(this); }

ColedMatrix BaseMatrix::as_column() const
{ REPORT return ColedMatrix(this); }

DiagedMatrix BaseMatrix::as_diagonal() const
{ REPORT return DiagedMatrix(this); }

MatedMatrix BaseMatrix::as_matrix(int nrx, int ncx) const
{ REPORT return MatedMatrix(this,nrx,ncx); }


void GeneralMatrix::operator=(Real f)
{ REPORT int i=storage; Real* s=store; while (i--) { *s++ = f; } }

void Matrix::operator=(const BaseMatrix& X)
{
   REPORT //CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::Rt);
} 

void SquareMatrix::operator=(const BaseMatrix& X)
{
   REPORT //CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::Rt);
   if (nrows_val != ncols_val)
      { Tracer tr("SquareMatrix(=)"); Throw(NotSquareException(*this)); }
}

void SquareMatrix::operator=(const Matrix& m)
{
   REPORT
   if (m.nrows_val != m.ncols_val)
      { Tracer tr("SquareMatrix(=Matrix)"); Throw(NotSquareException(*this)); }
   Eq(m);
}

void RowVector::operator=(const BaseMatrix& X)
{
   REPORT  // CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::RV);
   if (nrows_val!=1)
      { Tracer tr("RowVector(=)"); Throw(VectorException(*this)); }
}

void ColumnVector::operator=(const BaseMatrix& X)
{
   REPORT //CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::CV);
   if (ncols_val!=1)
      { Tracer tr("ColumnVector(=)"); Throw(VectorException(*this)); }
}

void SymmetricMatrix::operator=(const BaseMatrix& X)
{
   REPORT // CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::Sm);
}

void UpperTriangularMatrix::operator=(const BaseMatrix& X)
{
   REPORT //CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::UT);
}

void LowerTriangularMatrix::operator=(const BaseMatrix& X)
{
   REPORT //CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::LT);
}

void DiagonalMatrix::operator=(const BaseMatrix& X)
{
   REPORT // CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::Dg);
}

void IdentityMatrix::operator=(const BaseMatrix& X)
{
   REPORT // CheckConversion(X);
   // MatrixConversionCheck mcc;
   Eq(X,MatrixType::Id);
}


void CroutMatrix::operator=(const CroutMatrix& gm)
{
   if (&gm == this) { REPORT tag_val = -1; return; }
   REPORT
   if (indx > 0) { delete [] indx; indx = 0; }
   ((CroutMatrix&)gm).get_aux(*this);
   Eq(gm);
}
   




void GeneralMatrix::operator<<(const double* r)
{
   REPORT
   int i = storage; Real* s=store;
   while(i--) *s++ = (Real)*r++;
}


void GeneralMatrix::operator<<(const float* r)
{
   REPORT
   int i = storage; Real* s=store;
   while(i--) *s++ = (Real)*r++;
}


void GeneralMatrix::operator<<(const int* r)
{
   REPORT
   int i = storage; Real* s=store;
   while(i--) *s++ = (Real)*r++;
}


void GenericMatrix::operator=(const GenericMatrix& bmx)
{
   if (&bmx != this) { REPORT if (gm) delete gm; gm = bmx.gm->Image();}
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator=(const BaseMatrix& bmx)
{
   if (gm)
   {
      int counter=bmx.search(gm);
      if (counter==0) { REPORT delete gm; gm=0; }
      else { REPORT gm->Release(counter); }
   }
   else { REPORT }
   GeneralMatrix* gmx = ((BaseMatrix&)bmx).Evaluate();
   if (gmx != gm) { REPORT if (gm) delete gm; gm = gmx->Image(); }
   else { REPORT }
   gm->Protect();
}


/*************************** += etc ***************************************/


// GeneralMatrix operators

void GeneralMatrix::operator+=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GeneralMatrix::operator+=");
   // MatrixConversionCheck mcc;
   Protect();  // so it cannot get deleted during Evaluate
   GeneralMatrix* gm = ((BaseMatrix&)X).Evaluate();
   AddedMatrix am(this,gm);
   if (gm==this) Release(2); else Release();
   Eq2(am,type());
}

// GeneralMatrix operators

void GeneralMatrix::SP_eq(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GeneralMatrix::SP_eq");
   // MatrixConversionCheck mcc;
   Protect();  // so it cannot get deleted during Evaluate
   GeneralMatrix* gm = ((BaseMatrix&)X).Evaluate();
   SPMatrix spm(this,gm);
   if (gm==this) Release(2); else Release();
   Eq2(spm,type());
}

void GeneralMatrix::operator-=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GeneralMatrix::operator-=");
   // MatrixConversionCheck mcc;
   Protect();                                   // so it cannot get deleted
						// during Evaluate
   GeneralMatrix* gm = ((BaseMatrix&)X).Evaluate();
   SubtractedMatrix am(this,gm);
   if (gm==this) Release(2); else Release();
   Eq2(am,type());
}

void GeneralMatrix::operator*=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GeneralMatrix::operator*=");
   // MatrixConversionCheck mcc;
   Protect();                                   // so it cannot get deleted
						// during Evaluate
   GeneralMatrix* gm = ((BaseMatrix&)X).Evaluate();
   MultipliedMatrix am(this,gm);
   if (gm==this) Release(2); else Release();
   Eq2(am,type());
}

void GeneralMatrix::operator|=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GeneralMatrix::operator|=");
   // MatrixConversionCheck mcc;
   Protect();                                   // so it cannot get deleted
						// during Evaluate
   GeneralMatrix* gm = ((BaseMatrix&)X).Evaluate();
   ConcatenatedMatrix am(this,gm);
   if (gm==this) Release(2); else Release();
   Eq2(am,type());
}

void GeneralMatrix::operator&=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GeneralMatrix::operator&=");
   // MatrixConversionCheck mcc;
   Protect();                                   // so it cannot get deleted
						// during Evaluate
   GeneralMatrix* gm = ((BaseMatrix&)X).Evaluate();
   StackedMatrix am(this,gm);
   if (gm==this) Release(2); else Release();
   Eq2(am,type());
}

void GeneralMatrix::operator+=(Real r)
{
   REPORT
   Tracer tr("GeneralMatrix::operator+=(Real)");
   // MatrixConversionCheck mcc;
   ShiftedMatrix am(this,r);
   Release(); Eq2(am,type());
}

void GeneralMatrix::operator*=(Real r)
{
   REPORT
   Tracer tr("GeneralMatrix::operator*=(Real)");
   // MatrixConversionCheck mcc;
   ScaledMatrix am(this,r);
   Release(); Eq2(am,type());
}


// Generic matrix operators

void GenericMatrix::operator+=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GenericMatrix::operator+=");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   gm->Protect();            // so it cannot get deleted during Evaluate
   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate();
   AddedMatrix am(gm,gmx);
   if (gmx==gm) gm->Release(2); else gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::SP_eq(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GenericMatrix::SP_eq");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   gm->Protect();            // so it cannot get deleted during Evaluate
   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate();
   SPMatrix spm(gm,gmx);
   if (gmx==gm) gm->Release(2); else gm->Release();
   GeneralMatrix* gmy = spm.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator-=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GenericMatrix::operator-=");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   gm->Protect();            // so it cannot get deleted during Evaluate
   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate();
   SubtractedMatrix am(gm,gmx);
   if (gmx==gm) gm->Release(2); else gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator*=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GenericMatrix::operator*=");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   gm->Protect();            // so it cannot get deleted during Evaluate
   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate();
   MultipliedMatrix am(gm,gmx);
   if (gmx==gm) gm->Release(2); else gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator|=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GenericMatrix::operator|=");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   gm->Protect();            // so it cannot get deleted during Evaluate
   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate();
   ConcatenatedMatrix am(gm,gmx);
   if (gmx==gm) gm->Release(2); else gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator&=(const BaseMatrix& X)
{
   REPORT
   Tracer tr("GenericMatrix::operator&=");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   gm->Protect();            // so it cannot get deleted during Evaluate
   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate();
   StackedMatrix am(gm,gmx);
   if (gmx==gm) gm->Release(2); else gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator+=(Real r)
{
   REPORT
   Tracer tr("GenericMatrix::operator+= (Real)");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   ShiftedMatrix am(gm,r);
   gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}

void GenericMatrix::operator*=(Real r)
{
   REPORT
   Tracer tr("GenericMatrix::operator*= (Real)");
   if (!gm) Throw(ProgramException("GenericMatrix is null"));
   ScaledMatrix am(gm,r);
   gm->Release();
   GeneralMatrix* gmy = am.Evaluate();
   if (gmy != gm) { REPORT delete gm; gm = gmy->Image(); }
   else { REPORT }
   gm->Protect();
}


/************************* element access *********************************/

Real& Matrix::element(int m, int n)
{
   REPORT
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val)
      Throw(IndexException(m,n,*this,true));
   return store[m*ncols_val+n];
}

Real Matrix::element(int m, int n) const
{
   REPORT
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val)
      Throw(IndexException(m,n,*this,true));
   return store[m*ncols_val+n];
}

Real& SymmetricMatrix::element(int m, int n)
{
   REPORT
   if (m<0 || n<0 || m >= nrows_val || n>=ncols_val)
      Throw(IndexException(m,n,*this,true));
   if (m>=n) return store[tristore(m)+n];
   else return store[tristore(n)+m];
}

Real SymmetricMatrix::element(int m, int n) const
{
   REPORT
   if (m<0 || n<0 || m >= nrows_val || n>=ncols_val)
      Throw(IndexException(m,n,*this,true));
   if (m>=n) return store[tristore(m)+n];
   else return store[tristore(n)+m];
}

Real& UpperTriangularMatrix::element(int m, int n)
{
   REPORT
   if (m<0 || n<m || n>=ncols_val)
      Throw(IndexException(m,n,*this,true));
   return store[m*ncols_val+n-tristore(m)];
}

Real UpperTriangularMatrix::element(int m, int n) const
{
   REPORT
   if (m<0 || n<m || n>=ncols_val)
      Throw(IndexException(m,n,*this,true));
   return store[m*ncols_val+n-tristore(m)];
}

Real& LowerTriangularMatrix::element(int m, int n)
{
   REPORT
   if (n<0 || m<n || m>=nrows_val)
      Throw(IndexException(m,n,*this,true));
   return store[tristore(m)+n];
}

Real LowerTriangularMatrix::element(int m, int n) const
{
   REPORT
   if (n<0 || m<n || m>=nrows_val)
      Throw(IndexException(m,n,*this,true));
   return store[tristore(m)+n];
}

Real& DiagonalMatrix::element(int m, int n)
{
   REPORT
   if (n<0 || m!=n || m>=nrows_val || n>=ncols_val)
      Throw(IndexException(m,n,*this,true));
   return store[n];
}

Real DiagonalMatrix::element(int m, int n) const
{
   REPORT
   if (n<0 || m!=n || m>=nrows_val || n>=ncols_val)
      Throw(IndexException(m,n,*this,true));
   return store[n];
}

Real& DiagonalMatrix::element(int m)
{
   REPORT
   if (m<0 || m>=nrows_val) Throw(IndexException(m,*this,true));
   return store[m];
}

Real DiagonalMatrix::element(int m) const
{
   REPORT
   if (m<0 || m>=nrows_val) Throw(IndexException(m,*this,true));
   return store[m];
}

Real& ColumnVector::element(int m)
{
   REPORT
   if (m<0 || m>= nrows_val) Throw(IndexException(m,*this,true));
   return store[m];
}

Real ColumnVector::element(int m) const
{
   REPORT
   if (m<0 || m>= nrows_val) Throw(IndexException(m,*this,true));
   return store[m];
}

Real& RowVector::element(int n)
{
   REPORT
   if (n<0 || n>= ncols_val)  Throw(IndexException(n,*this,true));
   return store[n];
}

Real RowVector::element(int n) const
{
   REPORT
   if (n<0 || n>= ncols_val)  Throw(IndexException(n,*this,true));
   return store[n];
}

Real& BandMatrix::element(int m, int n)
{
   REPORT
   int w = upper_val+lower_val+1; int i = lower_val+n-m;
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this,true));
   return store[w*m+i];
}

Real BandMatrix::element(int m, int n) const
{
   REPORT
   int w = upper_val+lower_val+1; int i = lower_val+n-m;
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this,true));
   return store[w*m+i];
}

Real& UpperBandMatrix::element(int m, int n)
{
   REPORT
   int w = upper_val+1; int i = n-m;
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this,true));
   return store[w*m+i];
}

Real UpperBandMatrix::element(int m, int n) const
{
   REPORT
   int w = upper_val+1; int i = n-m;
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this,true));
   return store[w*m+i];
}

Real& LowerBandMatrix::element(int m, int n)
{
   REPORT
   int w = lower_val+1; int i = lower_val+n-m;
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this,true));
   return store[w*m+i];
}

Real LowerBandMatrix::element(int m, int n) const
{
   REPORT
   int w = lower_val+1; int i = lower_val+n-m;
   if (m<0 || m>= nrows_val || n<0 || n>= ncols_val || i<0 || i>=w)
      Throw(IndexException(m,n,*this,true));
   return store[w*m+i];
}

Real& SymmetricBandMatrix::element(int m, int n)
{
   REPORT
   int w = lower_val+1;
   if (m>=n)
   {
      REPORT
      int i = lower_val+n-m;
      if ( m>=nrows_val || n<0 || i<0 )
         Throw(IndexException(m,n,*this,true));
      return store[w*m+i];
   }
   else
   {
      REPORT
      int i = lower_val+m-n;
      if ( n>=nrows_val || m<0 || i<0 )
         Throw(IndexException(m,n,*this,true));
      return store[w*n+i];
   }
}

Real SymmetricBandMatrix::element(int m, int n) const
{
   REPORT
   int w = lower_val+1;
   if (m>=n)
   {
      REPORT
      int i = lower_val+n-m;
      if ( m>=nrows_val || n<0 || i<0 )
         Throw(IndexException(m,n,*this,true));
      return store[w*m+i];
   }
   else
   {
      REPORT
      int i = lower_val+m-n;
      if ( n>=nrows_val || m<0 || i<0 )
         Throw(IndexException(m,n,*this,true));
      return store[w*n+i];
   }
}

#ifdef use_namespace
}
#endif


///}
