280
37, 39, 40, 41, 42, 43, 44, 45, 51, 52, 56, 57, 57, 61, 61, 61, 62, 63, 63, 63, 64, 65, 66, 66, 67, 68, 69, 70, 71, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 82, 83, 83, 87, 88, 89, 90, 91, 91, 92, 93, 94, 95, 95, 96, 99, 100, 101, 102, 102, 103, 104, 104, 104, 105, 106, 107, 108, 109, 109, 110, 111, 112, 113, 114, 114, 115, 119, 120, 124, 125, 129, 130, 134, 135, 139, 140, 141, 141, 141, 142, 143, 144, 145, 145, 146, 147, 151, 152, 156, 157, 158, 159, 160, 161, 162, 166, 167, 167, 171, 172, 173, 173, 173, 174, 175, 176, 178, 178, 179, 180, 184, 185, 186, 186, 186, 187, 188, 189, 191, 191, 192, 193, 197, 197, 197, 198, 199, 200, 200, 200, 201, 202, 203, 203, 204, 205, 205, 205, 206, 207, 207, 208, 209, 210, 210, 211, 211, 211, 212, 213, 214, 215, 219, 220, 221, 221, 225, 226, 226, 226, 227, 228, 228, 229, 230, 231, 232, 233, 233, 234, 235, 235, 235, 236, 237, 238, 239, 240, 241, 241, 242, 243, 243, 243, 244, 245, 246, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 253, 254, 255, 255, 255, 256, 257, 257, 258, 259, 259, 259, 260, 260, 260, 261, 262, 262, 263, 264, 264, 265, 265, 266, 266, 267, 268, 269, 270, 271, 271, 272, 273, 273, 273, 274, 275, 275, 275, 276, 276, 277, 278, 279, 279, 280, 280, 280, 281, 282, 283, 284, 285, 286, 286, 287, 291, 292, 292, 292, 292, 296, 297, 301, 302, 303, 304, 305, 300, 150
/***************************************************************************
 *   Copyright (C) 2008 by Sverre Rabbelier                                *
 *   sverre@rabbelier.nl                                                   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "EditorChunk.h"
#include "EditorString.h"
#include "EditorBool.h"

#include "UBSocket.h"

#include "StringUtilities.h"
#include "Exceptions.h"
#include "TableImpls.h"

#include "Account.h"
#include "Chunk.h"
#include "ChunkManager.h"
#include "Room.h"
#include "RoomManager.h"

#include "chunkimporter.h"

EditorChunk::ChunkCommand EditorChunk::m_editName("Name", &EditorChunk::editName);
EditorChunk::ChunkCommand EditorChunk::m_editDescription("Description", &EditorChunk::editDescription);
EditorChunk::ChunkCommand EditorChunk::m_editRoom("Room", &EditorChunk::editRoom);
EditorChunk::ChunkCommand EditorChunk::m_listDetails("Details", &EditorChunk::listDetails);
EditorChunk::ChunkCommand EditorChunk::m_importChunk("Import", &EditorChunk::importChunk);
EditorChunk::ChunkCommand EditorChunk::m_showChunk("Show", &EditorChunk::showChunk);
EditorChunk::ChunkCommand EditorChunk::m_saveChunk("Save", &EditorChunk::saveChunk);

EditorChunk::EditorChunk(UBSocket* sock) :
OLCEditor(sock),
m_chunk(),
m_target(M_NONE)
{
	listCommands(Global::Get()->EmptyString);
}

EditorChunk::~EditorChunk(void)
{

}

void EditorChunk::OnFocus()
{		
	switch(m_target)
	{
		case M_NONE:
			return;
			
		case M_IMPORT:
			m_target = M_NONE;
			importChunk(m_value);
			break;
			
		case M_IMPORTACCEPT:
			m_target = M_NONE;
			importChunk(m_yesno ? "accept" : "reject");
			break;
			
		case M_IMPORTSAVECHUNK:
			m_target = M_NONE;
			importChunk(m_yesno ? "save" : "discard");
			break;
	}
	
	// m_target = M_NONE; // has to happen -before- importChunk is called since importChunk might set it to something else
}

std::string EditorChunk::lookup(const std::string& action)
{
	std::string name = OLCEditor::lookup(action);
	if(name.size() != 0)
		return name;
		
	ChunkCommand* act = ChunkInterpreter::Get()->translate(action);
	if(act)
		return act->getName();
		
	return Global::Get()->EmptyString;
}

void EditorChunk::dispatch(const std::string& action, const std::string& argument)
{
	ChunkCommand* act = ChunkInterpreter::Get()->translate(action);
	
	if(act && !m_chunk)
	{
		m_sock->Send("You need to be editing a chunk first.\n");
		m_sock->Send("(Use the 'edit' command.)\n");
		return;
	}
	
	if(act)
		act->Run(this, argument);
	else
		OLCEditor::dispatch(action, argument);
		
	return;
}

SavablePtr EditorChunk::getEditing()
{
	return m_chunk;
}

TableImplPtr EditorChunk::getTable()
{
	return db::TableImpls::Get()->CHUNKS;
}

KeysPtr EditorChunk::addNew()
{
	return mud::ChunkManager::Get()->Add();
}

std::vector<std::string> EditorChunk::getList()
{
	return mud::ChunkManager::Get()->List();
}

void EditorChunk::setEditing(KeysPtr keys)
{
	if(!keys->size())
	{
		m_chunk.reset();
		return;
	}
	
	m_chunk = mud::ChunkManager::Get()->GetByKey(keys->first()->getValue());
	return;
}

std::vector<std::string> EditorChunk::getCommands()
{
	return ChunkInterpreter::Get()->getWords();
}

EditorChunk::ChunkInterpreter::ChunkInterpreter(void)
{
	addWord("name", &m_editName);
	addWord("description", &m_editDescription);
	addWord("room", &m_editRoom);
	addWord("import", &m_importChunk);
	addWord("show", &m_showChunk);
	addWord("save", &m_saveChunk);
}

EditorChunk::ChunkInterpreter::~ChunkInterpreter(void)
{

}

void EditorChunk::editName(const std::string& argument)
{
	if(argument.size() == 0)
	{
		m_sock->Send("Chunk name can't be zero length!\n");
		return;
	}

	m_sock->Sendf("Chunk name changed from '%s' to '%s'.\n", m_chunk->getName().c_str(), argument.c_str());
	m_chunk->setName(argument);
	return;
}

void EditorChunk::editDescription(const std::string& argument)
{
	if(argument.size() == 0)
	{
		m_sock->Send("No argument, dropping you into the string editor!\n");
		return;
	}

	m_sock->Sendf("Chunk description changed from '%s' to '%s'.\n", m_chunk->getDescription().c_str(), argument.c_str());
	m_chunk->setDescription(argument);
	return;
}

void EditorChunk::editRoom(const std::string& argument)
{	
	int id = atoi(argument.c_str());
	if(id <= 0)
	{
		m_sock->Send("Please specify a room this Chunk belongs to.\n");
	}
	
	try
	{
		mud::RoomPtr room = mud::RoomManager::Get()->GetByKey(id);
		m_sock->Sendf("Room changed from '%s' to '%s'.\n", room->getName().c_str(), argument.c_str());
		m_chunk->setRoom(id);
	}
	catch(RowNotFoundException& e) 
	{
		m_sock->Sendf("'%s' is not a valid room!\n", argument.c_str());
		m_sock->Send(String::Get()->box(mud::RoomManager::Get()->List(), "Rooms"));
		return;
	}
}

void EditorChunk::importChunk(const std::string& argument)
{
	bool createdImporter = false;
	
	/** 
	 * There is no argument and no importer yes, create one
	 */ 
	if(argument.size() == 0 && !m_importer)
	{
		m_sock->Send("No argument, dropping you into the String Editor.\n");
		m_sock->Send("Paste your description there, when done the chunk will be imported.\n");
		m_sock->SetEditor(new EditorString(m_sock, m_value));
		m_target = M_IMPORT;
		return;
	}
	
	if(!m_importer)
	{
		ChunkImporterPtr importer(new ChunkImporter(argument));
		m_importer = importer;
		createdImporter = true;
		m_sock->Send("Import complete.\n");
	}
	
	if(argument.size() == 0 || createdImporter)
	{
		m_sock->Send("Importing would result in the following Chunk:\n");
		m_sock->Send(m_importer->getResult());
		m_sock->Send("Do you want to accept these changes?\n");
		m_sock->SetEditor(new EditorBool(m_sock, m_yesno));
		m_target = M_IMPORTACCEPT;
		return; 
	}
	
	if(!argument.compare("accept") || !argument.compare("reject"))
	{
		if(!argument.compare("accept"))
		{
			m_importer->Apply(m_chunk);
			m_sock->Send("Would you like to apply this import to another chunk as well?\n");
		}
		else		
		{
			m_sock->Send("Ok, canceled.\n");
			m_sock->Send("Would you like to apply this import to another chunk instead?\n");
		}
		
		m_sock->Send("(If so, this import will be saved while you remain in the chunk editor.\n");
		m_sock->Send("The next time you run import, even on another chunk, this import will be applied again.)\n");
		m_sock->SetEditor(new EditorBool(m_sock, m_yesno));
		m_target = M_IMPORTSAVECHUNK;
		return;
	}
	
	if(!argument.compare("save") || !argument.compare("discard"))
	{
		if(!argument.compare("save"))
		{
			m_sock->Send("Allright, this import will not be deleted till you change editors (e.g., type 'quit').\n");
			return;
		}
		else
		{
			m_sock->Send("Allright, import discarded.\n");
			m_importer.reset();
			return;
		}
	}
	
	m_sock->Send("Unknown action.\n");
}

void EditorChunk::listDetails(const std::string& argument)
{
	
}

void EditorChunk::showChunk(const std::string& argument)
{
	m_sock->Send(String::Get()->box(m_chunk->Show(), "Chunk"));
}

void EditorChunk::saveChunk(const std::string& argument)
{
	m_sock->Sendf("Saving chunk '%s'.\n", m_chunk->getName().c_str());
	m_chunk->Save();
	m_sock->Send("Saved.\n");
	return;
}
