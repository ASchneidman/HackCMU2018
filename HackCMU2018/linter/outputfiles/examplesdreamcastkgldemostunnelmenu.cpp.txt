149
13, 14, 19, 19, 20, 21, 21, 22, 23, 24, 25, 26, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 37, 38, 39, 44, 49, 50, 51, 51, 52, 53, 54, 55, 56, 56, 57, 58, 59, 60, 61, 62, 63, 63, 64, 64, 65, 65, 66, 67, 67, 67, 68, 69, 72, 73, 74, 75, 76, 77, 78, 79, 83, 84, 85, 86, 87, 88, 89, 90, 92, 92, 94, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 107, 107, 108, 108, 109, 110, 111, 112, 112, 113, 114, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 131, 131, 132, 132, 133, 134, 135, 136, 136, 137, 138, 142, 143, 144, 145, 145, 146, 147, 148, 148, 149, 150, 150, 150, 150, 151, 152, 152, 153, 154, 154, 155, 156, 157, 158
/* Kallistios ##version##

   menu.cpp
   (c)2001,2002 Paul Boese a.k.a. Axlen

   A cheap little menu class
*/

#include <string.h>
#include <kos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "plprint.h"
#include "menu.h"

CVSID("$Id: menu.cpp,v 1.1 2002/03/04 02:57:32 axlen Exp $");

void Menu::add(int min, int max, int amt, int* pval, char *pformat) {
	Menuitem_t* madd;	
	if (mlist == NULL) {
		mlist = (Menuitem_t*) malloc(sizeof(Menuitem_t));
		mlist->prev = NULL;
		mlist->next = NULL;
		madd = mcur = mtail = mlist;
	} else {
		madd = (Menuitem_t*) malloc(sizeof(Menuitem_t));
		mtail->next = madd;
		madd->prev = mtail;
		madd->next = NULL;
		mtail = madd;
	}
	madd->type = INTEGER_T;
	madd->min = min;
	madd->max = max;
	madd->amt = amt;
	madd->pvalue = pval;
	madd->pformat = (char*) malloc(strlen(pformat)+1); 
	memcpy(madd->pformat, pformat, strlen(pformat)+1);
	printf("[i**]menu->add = %d\n", strlen(pformat)+1);
}

// lvalue cast fix for C++, as proposed by Jim Ursetto
// http://sourceforge.net/mailarchive/message.php?msg_id=9293303
template <typename T, typename X> inline T& lvalue_cast(X& x) {
        return *( reinterpret_cast<T*>(&x) );  // *((T *)& x)
}

void Menu::add(float min, float max, float amt, float* pval, char *pformat) {
	Menuitem_t* madd;
	if (mlist == NULL) {
		mlist = (Menuitem_t*) malloc(sizeof(Menuitem_t));
		mlist->prev = NULL;
		mlist->next = NULL;
		madd = mcur = mtail = mlist;
	} else {
		madd = (Menuitem_t*) malloc(sizeof(Menuitem_t));
		mtail->next = madd;
		madd->prev = mtail;
		madd->next = NULL;
		mtail = madd;
	}
	madd->type = FLOAT_T;
	uf2i.f = min; madd->min = uf2i.i;
	uf2i.f = max; madd->max = uf2i.i;
	uf2i.f = amt; madd->amt = uf2i.i;
	lvalue_cast<float *>(madd->pvalue) = pval;
	madd->pformat = (char*) malloc(strlen(pformat)+1); 
	memcpy(madd->pformat, pformat, strlen(pformat)+1);
	printf("[f**]menu->add = %d\n", strlen(pformat)+1);
}
void Menu::next() {
	if (mcur == NULL) return;
	if (mcur->next != NULL) {
		// point to next menu item
		mcur = mcur->next;
	} else {
		// wrap around to first menu item
		mcur = mlist;
	}
}

void Menu::prev() {
	if (mcur == NULL) return;
	if (mcur->prev != NULL) {
		// point to prev menu item
		mcur = mcur->prev;
	} else {
		// wrap around to last menu item
		mcur = mtail;
	}
}
	
void Menu::inc() {
	int tmp;
	float fmp;

	if (mcur == NULL) return;
	switch(mcur->type) {
	case INTEGER_T:
		tmp = *mcur->pvalue;
		tmp += mcur->amt;
		if (tmp > mcur->max)
			return;
		(*mcur->pvalue) = tmp;
		break;
	case FLOAT_T:
		fmp = (float)*(float *)mcur->pvalue;
		uf2i.i = mcur->amt; fmp += uf2i.f;
		uf2i.i = mcur->max;
		if (fmp > uf2i.f)
			return;
		(*(float *)mcur->pvalue) = fmp;
		break;
	}
}

void Menu::dec() {
	int tmp;
	float fmp;
	
	if (mcur == NULL) return;
	switch(mcur->type) {
	case INTEGER_T:
		tmp = *mcur->pvalue;
		tmp -= mcur->amt;
		if (tmp < mcur->min)
			return;
		(*mcur->pvalue) = tmp;
		break;
	case FLOAT_T:
		fmp = (float)*(float *)mcur->pvalue;
		uf2i.i = mcur->amt; fmp -= uf2i.f;
		uf2i.i = mcur->min;
		if (fmp < uf2i.f)
			return;
		(*(float *)mcur->pvalue) = fmp;
		break;
	}
}

void Menu::draw(int x, int y, int yinc) {
	Menuitem_t* pmi = mlist;
	int cy = y;
	char buf[80];
	
	while (pmi != NULL) {
		if(pmi->type == INTEGER_T)
			sprintf(buf, pmi->pformat, *pmi->pvalue);
		else
			sprintf(buf, pmi->pformat, (float)*(float*)pmi->pvalue);
		if (pmi == mcur) {
		    plprint(x,cy, 1.0f, 1.0f, 0.0f, buf, 1);
		} else {
		    plprint(x,cy, 0.8f, 0.8f, 0.8f, buf, 1);
		}
		cy += yinc;
		pmi = pmi->next;
	}
}

Menuitem_t* Menu::mlist = NULL;
Menuitem_t* Menu::mtail = NULL;
Menuitem_t* Menu::mcur = NULL;
union uf2i_t Menu::uf2i;
