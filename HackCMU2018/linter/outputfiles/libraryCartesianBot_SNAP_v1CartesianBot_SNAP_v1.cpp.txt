786
16, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 37, 38, 39, 40, 46, 47, 48, 50, 51, 55, 56, 57, 59, 60, 62, 63, 67, 68, 69, 71, 72, 73, 73, 74, 75, 79, 80, 81, 81, 81, 82, 83, 84, 86, 87, 87, 87, 88, 89, 90, 92, 93, 93, 93, 94, 95, 96, 100, 101, 102, 102, 102, 103, 103, 104, 105, 106, 107, 107, 108, 109, 109, 109, 110, 110, 111, 112, 113, 114, 114, 115, 116, 116, 116, 117, 117, 118, 119, 120, 124, 125, 126, 128, 129, 131, 132, 136, 137, 138, 139, 139, 140, 141, 142, 146, 147, 148, 148, 149, 150, 150, 150, 151, 152, 153, 154, 155, 155, 156, 157, 158, 158, 159, 159, 159, 160, 161, 161, 161, 162, 162, 163, 164, 165, 166, 167, 169, 170, 171, 172, 173, 174, 175, 175, 176, 176, 176, 177, 178, 178, 178, 179, 180, 180, 180, 181, 182, 183, 184, 186, 187, 188, 189, 191, 192, 192, 192, 193, 194, 194, 194, 195, 196, 197, 198, 200, 201, 201, 202, 203, 204, 204, 205, 206, 206, 206, 207, 208, 208, 208, 209, 210, 211, 212, 214, 215, 216, 217, 218, 218, 219, 220, 220, 220, 221, 222, 223, 224, 225, 225, 226, 226, 226, 227, 228, 228, 228, 229, 230, 230, 230, 231, 233, 234, 234, 235, 236, 237, 237, 238, 239, 239, 239, 240, 241, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 248, 248, 249, 250, 250, 250, 251, 252, 252, 252, 253, 254, 254, 255, 256, 256, 257, 257, 258, 259, 259, 260, 261, 261, 261, 262, 263, 264, 265, 266, 266, 267, 267, 267, 268, 269, 269, 269, 270, 271, 271, 271, 272, 273, 274, 275, 276, 277, 279, 280, 280, 280, 281, 282, 282, 282, 283, 284, 285, 286, 287, 288, 290, 291, 291, 291, 292, 293, 293, 293, 294, 295, 296, 297, 298, 299, 300, 301, 301, 302, 302, 302, 303, 304, 304, 304, 305, 305, 306, 307, 307, 307, 308, 309, 310, 312, 313, 314, 315, 317, 318, 318, 318, 319, 319, 320, 321, 321, 321, 322, 323, 324, 326, 327, 328, 329, 331, 332, 332, 332, 333, 333, 334, 335, 335, 335, 336, 337, 338, 340, 341, 342, 343, 344, 348, 349, 350, 351, 353, 354, 354, 354, 355, 356, 357, 358, 359, 360, 361, 363, 364, 364, 365, 366, 366, 366, 367, 368, 369, 370, 370, 371, 371, 371, 372, 373, 374, 375, 375, 376, 376, 376, 377, 378, 379, 380, 382, 382, 383, 384, 386, 387, 388, 388, 388, 389, 390, 391, 392, 392, 393, 393, 393, 394, 395, 396, 397, 397, 398, 398, 398, 399, 400, 401, 402, 404, 404, 405, 406, 408, 409, 410, 410, 411, 412, 412, 412, 413, 414, 415, 416, 416, 416, 417, 417, 417, 418, 419, 420, 421, 421, 422, 422, 422, 423, 424, 425, 426, 428, 429, 430, 431, 432, 433, 434, 436, 437, 438, 439, 440, 442, 443, 444, 446, 446, 447, 448, 448, 448, 449, 450, 451, 452, 452, 453, 453, 453, 454, 455, 456, 457, 457, 458, 458, 458, 459, 460, 461, 463, 463, 464, 466, 466, 467, 468, 468, 469, 469, 470, 471, 472, 472, 473, 475, 476, 477, 477, 477, 478, 479, 480, 481, 482, 482, 482, 483, 484, 485, 486, 487, 487, 487, 488, 489, 490, 491, 493, 494, 494, 495, 496, 497, 498, 499, 500, 501, 503, 504, 505, 506, 507, 508, 509, 511, 512, 513, 514, 515, 516, 517, 518, 519, 519, 520, 520, 521, 522, 522, 523, 523, 524, 524, 525, 527, 529, 530, 531, 532, 533, 534, 535, 537, 537, 538, 539, 540, 541, 542, 544, 545, 547, 547, 548, 549, 550, 550, 551, 551, 552, 553, 553, 553, 554, 555, 555, 556, 556, 557, 558, 559, 560, 561, 562, 563, 564, 564, 565, 565, 565, 566, 568, 568, 569, 570, 571, 572, 573, 574, 575, 577, 577, 578, 579, 579, 580, 580, 581, 582, 582, 583, 583, 584, 585, 585, 586, 586, 587, 588, 589, 590, 591, 592, 592, 593, 595, 596, 597, 598, 599, 600, 601, 602, 604, 605, 606, 607, 608, 609, 610, 611, 613, 614, 614, 615, 617, 618, 619, 620, 621, 622, 623, 625, 627, 628, 628, 628, 629, 629, 630, 632, 632, 633, 634, 635, 635, 636, 636, 636, 637, 637, 638, 640, 640, 641, 642, 643, 643, 644, 644, 644, 645, 645, 646, 648, 648, 649, 650, 652, 652, 653, 655, 655, 656, 657, 658, 659, 659, 660, 661, 662, 663, 664, 665, 666, 670, 671, 672, 673, 677, 678, 679, 680, 681, 681, 685, 686, 687, 688, 689, 693, 694, 695, 696, 697
#include "CartesianBot_SNAP_v1.h"
#include <avr/interrupt.h>
#include "HardwareSerial.h"

/**********************************
*  Global variable instantiations
**********************************/

byte x_notify = 255;
byte y_notify = 255;
byte z_notify = 255;

byte x_sync_mode = sync_none;
byte y_sync_mode = sync_none;

//our mode holder.
byte bot_mode = MODE_PAUSE;
byte x_mode = MODE_PAUSE;
byte y_mode = MODE_PAUSE;
byte z_mode = MODE_PAUSE;

SIGNAL(SIG_OUTPUT_COMPARE1A)
{
	if (bot_mode == MODE_DDA)
		interruptDDA();
	else if (bot_mode == MODE_HOMERESET)
		interruptHomeReset();
	else if (bot_mode == MODE_SEEK)
		interruptSeek();
	else if (bot_mode == MODE_FIND_MIN)
		interruptFindMin();
	else if (bot_mode == MODE_FIND_MAX)
		interruptFindMax();
	else if (bot_mode == MODE_RUN)
		interruptRun();
	else
	{
		bot.mode = MODE_PAUSE;
		bot.disableTimerInterrupt();
	}
}



void interruptDDA()
{
	if (bot.x.can_step)
		bot.x.ddaStep(bot.max_delta);

	if (bot.y.can_step)
		bot.y.ddaStep(bot.max_delta);
}

void interruptHomeReset()
{
	if (x_mode == MODE_HOMERESET && !bot.x.atMin())
			bot.x.stepper.pulse();

	if (y_mode == MODE_HOMERESET && !bot.y.atMin())
			bot.y.stepper.pulse();

	if (z_mode == MODE_HOMERESET && !bot.z.atMin())
			bot.z.stepper.pulse();
}

void interruptSeek()
{
	if (bot.x.can_step)
		bot.x.doStep();

	if (bot.y.can_step)
		bot.y.doStep();
	
	if (bot.z.can_step)
		bot.z.doStep();
}

void interruptFindMin()
{
	if (x_mode == MODE_FIND_MIN)
	{
		if (!bot.x.atMin())
			bot.x.stepper.pulse();
	}

	if (y_mode == MODE_FIND_MIN)
	{
		if (!bot.x.atMin())
			bot.y.stepper.pulse();
	}

	if (z_mode == MODE_FIND_MIN)
	{
		if (!bot.x.atMin())
			bot.z.stepper.pulse();
	}
}

void interruptFindMax()
{
	if (x_mode == MODE_FIND_MAX)
	{
		//do a step if we're not there yet.
		if (!bot.x.atMax())
			bot.x.doStep();
	}
	
	if (y_mode == MODE_FIND_MAX)
	{
		//do a step if we're not there yet.
		if (!bot.y.atMax())
			bot.y.doStep();
	}
	
	if (z_mode == MODE_FIND_MAX)
	{
		//do a step if we're not there yet.
		if (!bot.z.atMax())
			bot.z.doStep();
	}
}

void interruptRun()
{
	if (x_mode == MODE_RUN && bot.x.can_step)
		bot.x.stepper.pulse();

	if (y_mode == MODE_RUN && bot.y.can_step)
		bot.y.stepper.pulse();

	if (z_mode == MODE_RUN && bot.z.can_step)
		bot.z.stepper.pulse();
}

void setup_cartesian_bot_snap_v1()
{
	bot.setupTimerInterrupt();
	bot.disableTimerInterrupt();
	
	snap.addDevice(X_ADDRESS);
	snap.addDevice(Y_ADDRESS);
	snap.addDevice(Z_ADDRESS);
}

void cartesian_bot_snap_v1_loop()
{
	bot.readState();
	
	if (bot_mode == MODE_PAUSE)
	{
		x_mode = MODE_PAUSE;
		y_mode = MODE_PAUSE;
		z_mode = MODE_PAUSE;
		bot.disableTimerInterrupt();
		
		return;
	}
	else if (bot_mode == MODE_DDA)
	{
		if (bot.atTarget())
		{
			//stop us.
			bot_mode = MODE_PAUSE;
			x_mode = MODE_PAUSE;
			y_mode = MODE_PAUSE;
			z_mode = MODE_PAUSE;
			bot.disableTimerInterrupt();

			if (x_notify != 255)
				notifyDDA(x_notify, X_ADDRESS, bot.x.current);
			if (y_notify != 255)
				notifyDDA(y_notify, Y_ADDRESS, bot.y.current);
		}
	}
	else if (bot_mode == MODE_HOMERESET)
	{
		if (x_mode == MODE_HOMERESET)
		{
			if (bot.x.atMin())
			{
				x_mode = MODE_PAUSE;
				bot.x.setPosition(0);
				bot.x.setTarget(0);
				bot.x.stepper.setDirection(RS_FORWARD);

				if (x_notify != 255)
					notifyHomeReset(x_notify, X_ADDRESS);
			}
		}

		if (y_mode == MODE_HOMERESET)
		{
			if (bot.y.atMin())
			{
				y_mode = MODE_PAUSE;
				bot.y.setPosition(0);
				bot.y.setTarget(0);
				bot.y.stepper.setDirection(RS_FORWARD);

				if (y_notify != 255)
					notifyHomeReset(y_notify, Y_ADDRESS);	
			}
		}
		
		if (z_mode == MODE_HOMERESET)
		{
			if (bot.z.atMin())
			{
				z_mode = MODE_PAUSE;
				bot.z.setPosition(0);
				bot.z.setTarget(0);
				bot.z.stepper.setDirection(RS_FORWARD);

				if (z_notify != 255)
					notifyHomeReset(z_notify, Z_ADDRESS);
			}
		}
		
		if (x_mode == MODE_PAUSE && y_mode == MODE_PAUSE && z_mode == MODE_PAUSE)
		{
			bot_mode = MODE_PAUSE;
			bot.disableTimerInterrupt();
		}
	}
	else if (bot_mode == MODE_SEEK)
	{
		if (x_mode == MODE_SEEK)
		{
			if (!bot.x.can_step)
			{
				x_mode = MODE_PAUSE;

				if (x_notify != 255)
					notifySeek(x_notify, X_ADDRESS, (int)bot.x.current);
			}
		}
		
		if (y_mode == MODE_SEEK)
		{
			if (!bot.y.can_step)
			{
				y_mode = MODE_PAUSE;
			
				if (y_notify != 255)
					notifySeek(y_notify, Y_ADDRESS, (int)bot.y.current);
			}
		}
		
		if (z_mode == MODE_SEEK)
		{
			if (!bot.z.can_step)
			{
				z_mode = MODE_PAUSE;
			
				if (z_notify != 255)
					notifySeek(z_notify, Z_ADDRESS, (int)bot.z.current);
			}	
		}
		
		if (x_mode == MODE_PAUSE && y_mode == MODE_PAUSE && z_mode == MODE_PAUSE)
		{
			bot_mode = MODE_PAUSE;
			bot.disableTimerInterrupt();
		}
	}
	else if (bot_mode == MODE_FIND_MIN)
	{
		if (x_mode == MODE_FIND_MIN)
		{
			if (bot.x.atMin())
			{
				bot.x.setPosition(0);
				bot.x.stepper.setDirection(RS_FORWARD);
				x_mode = MODE_FIND_MAX;
				bot_mode = MODE_FIND_MAX;
			}
		}

		if (y_mode == MODE_FIND_MIN)
		{
			if (bot.y.atMin())
			{
				bot.y.setPosition(0);
				bot.y.stepper.setDirection(RS_FORWARD);
				y_mode = MODE_FIND_MAX;
				bot_mode = MODE_FIND_MAX;
			}
		}

		if (z_mode == MODE_FIND_MIN)
		{
			if (bot.z.atMin())
			{
				bot.z.setPosition(0);
				bot.z.stepper.setDirection(RS_FORWARD);
				z_mode = MODE_FIND_MAX;
				bot_mode = MODE_FIND_MAX;
			}
		}
	}
	else if (bot_mode == MODE_FIND_MAX)
	{
		if (x_mode == MODE_FIND_MAX)
		{
			//are we there yet?
			if (bot.x.atMax())
			{
				bot.x.max = bot.x.current;
				x_mode = MODE_PAUSE;
				bot.disableTimerInterrupt();

				if (x_notify != 255)
					notifyCalibrate(x_notify, X_ADDRESS, bot.x.max);
			}
		}

		if (y_mode == MODE_FIND_MAX)
		{
			//are we there yet?
			if (bot.y.atMax())
			{
				bot.y.max = bot.y.current;
				y_mode = MODE_PAUSE;
				bot.disableTimerInterrupt();

				if (x_notify != 255)
					notifyCalibrate(x_notify, X_ADDRESS, bot.y.max);
			}
		}

		if (z_mode == MODE_FIND_MAX)
		{
			//are we there yet?
			if (bot.z.atMax())
			{
				bot.z.max = bot.z.current;
				z_mode = MODE_PAUSE;
				bot.disableTimerInterrupt();

				if (x_notify != 255)
					notifyCalibrate(x_notify, X_ADDRESS, bot.z.max);
			}
		}
	}
}

void process_cartesian_bot_snap_commands_v1()
{
	byte cmd = snap.getByte(0);
	byte dest = snap.getDestination();
	int position = 0;

	switch (cmd)
	{
		case CMD_VERSION:
			snap.startMessage(0, dest);
			snap.sendDataByte(CMD_VERSION);  // Response type 0
			snap.sendDataByte(VERSION_MAJOR);
			snap.sendDataByte(VERSION_MINOR);
			snap.sendMessage();
		break;

		case CMD_FORWARD:
			//okay, set our speed.
			if (dest == X_ADDRESS)
			{
				bot.x.stepper.setDirection(RS_FORWARD);
				x_mode = MODE_RUN;
			}
			else if (dest == Y_ADDRESS)
			{
				bot.y.stepper.setDirection(RS_FORWARD);
				y_mode = MODE_RUN;
			}
			else if (dest == Z_ADDRESS)
			{
				bot.z.stepper.setDirection(RS_FORWARD);
				z_mode = MODE_RUN;
			}
			bot_mode = MODE_RUN;

			//emulate PIC timer
			bot.setTimer(picTimerSimulate(snap.getByte(1)));
		break;

		case CMD_REVERSE:
			if (dest == X_ADDRESS)
			{
				bot.x.stepper.setDirection(RS_REVERSE);
				x_mode = MODE_RUN;
			}
			else if (dest == Y_ADDRESS)
			{
				bot.y.stepper.setDirection(RS_REVERSE);
				y_mode = MODE_RUN;
			}
			else if (dest == Z_ADDRESS)
			{
				bot.z.stepper.setDirection(RS_REVERSE);
				z_mode = MODE_RUN;
			}
			bot_mode = MODE_RUN;

			//emulate PIC timer
			bot.setTimer(picTimerSimulate(snap.getByte(1)));
		break;

		case CMD_SETPOS:
			position = snap.getInt(1);
			
			if (dest == X_ADDRESS)
			{
				bot.x.setPosition(position);
				bot.x.setTarget(position);
			}
			else if (dest == Y_ADDRESS) 
			{
				bot.y.setPosition(position);
				bot.y.setTarget(position);
			}
			else if (dest == Z_ADDRESS)
			{
				bot.z.setPosition(position);
				bot.z.setTarget(position);
			}
		break;

		case CMD_GETPOS:
			if (dest == X_ADDRESS)
				position = bot.x.current;
			else if (dest == Y_ADDRESS)
				position = bot.y.current;
			else if (dest == Z_ADDRESS)
				position = bot.z.current;

			snap.startMessage(0, dest);
			snap.sendDataByte(CMD_GETPOS);
			snap.sendDataInt(position);
			snap.sendMessage();
		break;

		case CMD_SEEK:
			// Goto position
			position = snap.getInt(2);

			//okay, set our speed.
			if (dest == X_ADDRESS)
			{
				x_mode = MODE_SEEK;
				bot.x.setTarget(position);
			}
			else if (dest == Y_ADDRESS)
			{
				y_mode = MODE_SEEK;
				bot.y.setTarget(position);
			}
			else if (dest == Z_ADDRESS)
			{
				z_mode = MODE_SEEK;
				bot.z.setTarget(position);
			}

			//emulate the PIC timer speeds
			bot.setTimer(picTimerSimulate(snap.getByte(1)));

			//get everything current.
			bot.readState();
			
			//start our seek.
			bot_mode = MODE_SEEK;
			bot.enableTimerInterrupt();
			
	    break;

		case CMD_FREE:
			if (dest == X_ADDRESS)
			{
				bot.x.stepper.disable();
				x_mode = MODE_PAUSE;
			}
			if (dest == Y_ADDRESS)
			{
				bot.y.stepper.disable();
				y_mode = MODE_PAUSE;
			}
			if (dest == Z_ADDRESS)
			{
				bot.z.stepper.disable();
				z_mode = MODE_PAUSE;
			}
		break;

		case CMD_NOTIFY:
			// Parameter is receiver of notification, or 255 if notification should be turned off
			if (dest == X_ADDRESS)
				x_notify = snap.getByte(1);
			if (dest == Y_ADDRESS)
				y_notify = snap.getByte(1);
			if (dest == Z_ADDRESS)
				z_notify = snap.getByte(1);
		break;

		case CMD_SYNC:
			// Set sync mode.. used to determine which direction to move slave stepper
			if (dest == X_ADDRESS)
				x_sync_mode = snap.getByte(1);
			if (dest == Y_ADDRESS)
				y_sync_mode = snap.getByte(1);
		break;

		case CMD_CALIBRATE:
			// Request calibration (search at given speed)
			if (dest == X_ADDRESS)
				x_mode = MODE_FIND_MIN;
			else if (dest == Y_ADDRESS)
				y_mode = MODE_FIND_MIN;
			else if (dest == Z_ADDRESS)
				z_mode = MODE_FIND_MIN;
			
			//emulate PIC speeds
			bot.setTimer(picTimerSimulate(snap.getByte(1)));
			
			//start our calibration.
			bot_mode = MODE_FIND_MIN;		
			bot.enableTimerInterrupt();

		break;

		case CMD_GETRANGE:
			if (dest == X_ADDRESS)
				position = bot.x.max;
			else if (dest == Y_ADDRESS)
				position = bot.y.max;
			else
				position = bot.z.max;

			//tell the host.
			snap.startMessage(0, dest);
			snap.sendDataByte(CMD_GETPOS);
			snap.sendDataInt(position);
			snap.sendMessage();
		break;

		case CMD_DDA:
			int target;

			//get our coords.
			position = snap.getInt(2);
			target = snap.getInt(4);
			
			//which axis is leading?
			if (dest == X_ADDRESS)
			{
				bot.x.setTarget(position);
				
				//we can figure out the target based on the sync mode
				if (y_sync_mode == sync_inc)
					bot.y.setTarget(bot.y.current + target);
				else if (y_sync_mode == sync_dec)
					bot.y.setTarget(bot.y.current - target);
				else
					bot.y.setTarget(bot.y.current);
			}
			else if (dest == Y_ADDRESS)
			{
				bot.y.setTarget(position);

				//we can figure out the target based on the sync mode
				if (x_sync_mode == sync_inc)
					bot.x.setTarget(bot.x.current + target);
				else if (x_sync_mode == sync_dec)
					bot.x.setTarget(bot.x.current - target);
				else
					bot.x.setTarget(bot.x.current);
			}

			//set z's target to itself.
			bot.z.setTarget(bot.z.current);
			
			//set our speed.
			bot.setTimer(picTimerSimulate(snap.getByte(1)));
			
			//init our DDA stuff!
			bot.calculateDDA();
			
			//start the dda!
			bot_mode = MODE_DDA;
			x_mode = MODE_DDA;
			y_mode = MODE_DDA;
			z_mode = MODE_DDA;
			bot.enableTimerInterrupt();
					
		break;

		case CMD_FORWARD1:
			if (dest == X_ADDRESS)
				bot.x.forward1();
			else if (dest == Y_ADDRESS)
				bot.y.forward1();
			else if (dest == Z_ADDRESS)
				bot.z.forward1();
		break;

		case CMD_BACKWARD1:
			if (dest == X_ADDRESS)
				bot.x.reverse1();
			else if (dest == Y_ADDRESS)
				bot.y.reverse1();
			else if (dest == Z_ADDRESS)
				bot.z.reverse1();
		break;

		case CMD_SETPOWER:
			//doesnt matter because power is handled by the stepper driver board!
		break;

		case CMD_GETSENSOR:
			snap.startMessage(0, dest);
			snap.sendDataByte(CMD_GETSENSOR);
			// Dummy values to satisfy PIC emulation
			snap.sendDataInt(0);
			snap.sendMessage();
		break;

		case CMD_HOMERESET:

			if (dest == X_ADDRESS)
			{
				//configure our axis
				bot.x.stepper.setDirection(RS_REVERSE);

				//tell our axis to go home.
				x_mode = MODE_HOMERESET;
			}
			else if (dest == Y_ADDRESS)
			{
				//configure our axis
				bot.y.stepper.setDirection(RS_REVERSE);

				//tell our axis to go home.
				y_mode = MODE_HOMERESET;
			}
			else if (dest == Z_ADDRESS)
			{
				//configure our axis
				bot.z.stepper.setDirection(RS_REVERSE);

				//tell our axis to go home.
				z_mode = MODE_HOMERESET;
			}

			//emulate PIC timer stuff
			bot.setTimer(picTimerSimulate(snap.getByte(1)));

			//starts our home reset mode.
			bot_mode = MODE_HOMERESET;
			bot.enableTimerInterrupt();
		break;
		
		case CMD_DEVICE_TYPE:
			snap.startMessage(0, dest);
			snap.sendDataByte(CMD_DEVICE_TYPE);
			snap.sendDataByte(DEVICE_TYPE);
			snap.sendMessage();
		break;
	}
}

void notifyHomeReset(byte to, byte from)
{
	snap.startMessage(to, from);
	snap.sendDataByte(CMD_HOMERESET);
	snap.sendMessage();
}

void notifyCalibrate(byte to, byte from, int position)
{
	snap.startMessage(to, from);
	snap.sendDataByte(CMD_CALIBRATE);
	snap.sendDataInt(position);
	snap.sendMessage();	
}

void notifySeek(byte to, byte from, int position)
{
	snap.startMessage(to, from);
	snap.sendDataByte(CMD_SEEK);
	snap.sendDataInt(position);
	snap.sendMessage();
}

void notifyDDA(byte to, byte from, int position)
{
	snap.startMessage(to, from);
	snap.sendDataByte(CMD_DDA);
	snap.sendDataInt(position);
	snap.sendMessage();
}
