1042
42, 43, 44, 45, 46, 49, 51, 53, 54, 62, 62, 63, 64, 67, 67, 68, 71, 71, 72, 73, 74, 75, 77, 77, 78, 78, 79, 80, 81, 82, 85, 85, 86, 87, 88, 89, 90, 90, 93, 93, 94, 94, 95, 95, 96, 96, 97, 98, 101, 101, 101, 102, 103, 103, 103, 106, 107, 108, 109, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 115, 116, 118, 122, 129, 131, 131, 132, 135, 135, 136, 137, 139, 139, 140, 144, 144, 144, 145, 148, 156, 156, 157, 159, 160, 161, 162, 162, 164, 165, 166, 167, 167, 168, 169, 170, 170, 171, 171, 175, 175, 176, 178, 178, 181, 182, 185, 186, 188, 188, 191, 192, 193, 193, 196, 197, 199, 202, 206, 209, 216, 217, 219, 222, 223, 227, 228, 232, 234, 235, 235, 235, 236, 237, 238, 239, 240, 240, 244, 245, 245, 245, 246, 247, 248, 250, 251, 252, 256, 257, 257, 257, 258, 259, 260, 262, 263, 264, 267, 268, 268, 268, 269, 270, 271, 277, 278, 280, 286, 286, 287, 287, 289, 290, 290, 290, 291, 291, 292, 292, 294, 295, 296, 298, 300, 304, 310, 312, 314, 315, 315, 315, 316, 317, 317, 318, 319, 320, 320, 321, 322, 322, 323, 323, 324, 325, 326, 326, 326, 327, 328, 329, 330, 331, 332, 332, 333, 333, 333, 334, 335, 336, 337, 338, 338, 339, 340, 341, 344, 345, 348, 349, 352, 353, 356, 357, 360, 361, 364, 367, 368, 368, 368, 369, 369, 370, 370, 377, 378, 379, 380, 381, 383, 386, 386, 386, 387, 387, 388, 388, 389, 391, 392, 392, 393, 399, 400, 402, 403, 403, 403, 404, 407, 408, 408, 408, 409, 412, 413, 413, 413, 414, 418, 420, 421, 424, 425, 426, 427, 428, 430, 432, 438, 446, 451, 452, 452, 453, 453, 454, 454, 455, 455, 458, 458, 463, 463, 465, 466, 467, 468, 471, 472, 476, 477, 478, 479, 480, 482, 491, 491, 493, 493, 496, 498, 499, 499, 499, 500, 500, 501, 501, 502, 502, 503, 503, 504, 504, 506, 507, 507, 509, 510, 510, 511, 512, 512, 513, 513, 513, 514, 514, 515, 516, 516, 518, 519, 519, 521, 521, 522, 523, 523, 524, 524, 526, 526, 527, 528, 528, 529, 529, 530, 530, 531, 532, 533, 535, 535, 536, 536, 536, 538, 539, 539, 541, 542, 543, 543, 544, 545, 546, 546, 546, 547, 549, 550, 550, 551, 551, 552, 552, 553, 554, 554, 555, 557, 558, 558, 559, 559, 559, 560, 562, 563, 563, 564, 564, 565, 565, 566, 568, 569, 569, 570, 572, 573, 573, 575, 576, 578, 578, 579, 579, 579, 581, 582, 582, 582, 583, 585, 585, 586, 586, 587, 588, 590, 590, 591, 591, 591, 593, 594, 594, 595, 597, 597, 597, 598, 599, 600, 602, 602, 603, 603, 603, 605, 606, 606, 607, 609, 609, 610, 610, 611, 612, 614, 614, 615, 615, 615, 617, 618, 618, 619, 621, 621, 621, 622, 623, 624, 627, 628, 628, 630, 631, 634, 634, 635, 635, 636, 638, 639, 639, 641, 642, 642, 643, 644, 644, 644, 647, 648, 648, 649, 649, 650, 651, 651, 652, 652, 653, 654, 655, 655, 656, 656, 657, 657, 658, 659, 660, 661, 661, 661, 661, 662, 662, 662, 663, 664, 665, 665, 666, 666, 667, 667, 668, 668, 669, 670, 672, 673, 673, 675, 676, 676, 677, 677, 678, 681, 682, 682, 682, 683, 686, 687, 687, 689, 690, 690, 691, 692, 692, 692, 694, 695, 695, 696, 696, 697, 698, 699, 699, 700, 700, 700, 701, 702, 703, 703, 704, 704, 705, 705, 706, 706, 707, 708, 708, 709, 710, 712, 713, 713, 715, 716, 716, 717, 718, 718, 728, 728, 729, 729, 731, 732, 732, 732, 733, 735, 735, 736, 736, 737, 738, 748, 748, 749, 749, 751, 752, 752, 752, 753, 755, 755, 755, 756, 757, 758, 769, 770, 770, 771, 773, 773, 773, 773, 774, 785, 786, 786, 787, 789, 789, 789, 790, 790, 791, 801, 801, 802, 802, 802, 804, 805, 805, 806, 808, 808, 809, 810, 811, 811, 820, 820, 821, 821, 821, 823, 824, 824, 825, 827, 828, 828, 828, 828, 829, 829, 830, 831, 832, 842, 842, 843, 843, 843, 845, 846, 846, 846, 847, 849, 850, 850, 850, 851, 852, 853, 854, 864, 864, 865, 865, 865, 867, 868, 868, 869, 871, 872, 872, 872, 873, 873, 874, 875, 876, 886, 896, 897, 900, 901, 901, 902, 904, 907, 907, 908, 908, 908, 910, 911, 911, 912, 912, 913, 914, 915, 915, 915, 916, 917, 917, 918, 918, 919, 919, 920, 921, 921, 922, 923, 923, 924, 924, 925, 925, 926, 926, 927, 928, 929, 929, 930, 932, 932, 933, 934, 937, 937, 938, 938, 938, 940, 941, 941, 942, 942, 943, 944, 945, 945, 945, 946, 947, 947, 948, 948, 949, 949, 950, 951, 951, 952, 953, 953, 954, 954, 955, 955, 956, 956, 957, 958, 959, 959, 960, 962, 962, 963, 964, 967, 967, 968, 971, 974, 974, 975, 985, 985, 986, 989, 990, 993, 994, 994, 995, 995, 997, 997, 998, 1000, 1001, 1003, 1004, 1005, 1005, 1006, 1007, 1008, 1009, 1010, 1010, 1010, 1011, 1011, 1011, 1012, 1014, 1015, 1016, 1017, 1018, 1018, 1018, 1019, 1020, 1020, 1020, 1021, 1021, 1022, 1022, 1023, 1024, 1025, 1025, 1026, 1026, 1026, 1027, 1027, 1027, 1028, 1029, 1029, 1029, 1030, 1031, 1032, 1033, 1034, 1034, 1034, 1035, 1035, 1035, 1035, 1036, 1037, 1038, 1038, 1039, 1039, 1039, 1040, 1041, 1042, 1042, 1042, 1042, 1043, 1044, 1045, 1045, 1045, 1045, 1046, 1047, 1048, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1058, 1059, 1059, 1060, 1060, 1060, 1061, 1061, 1063, 1064, 1065, 1065, 1066, 1066, 1067, 1067, 1067, 1068, 1068, 1070, 1071, 1072, 1072, 1073, 1073, 1074, 1074, 1074, 1075, 1075, 1077, 1078, 1079, 1082, 1082, 1085, 1085, 1088, 1089, 1090, 1090, 1090, 1091, 1091, 1092, 1093, 1095, 1096, 1097, 1098, 1098, 1098, 1099, 1100, 1100, 1101, 1103, 1106, 1107, 1108, 1111, 1113, 1113, 1114, 1114, 1115, 1115, 1116, 1118, 1118, 1119, 1119, 1120, 1120, 1121, 1123, 1123, 1124, 1124, 1125, 1125, 1126, 1130, 1131, 1132, 1133, 1136, 1138, 1140, 1149, 1149, 1150, 1151, 1151, 1152, 1152, 1162, 1163, 1163, 1167, 1167, 1168, 1170
/*
 * Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.
 *
 * (c) Copyright 1996 - 2001 Gary Henderson (gary.henderson@ntlworld.com) and
 *                           Jerremy Koot (jkoot@snes9x.com)
 *
 * Super FX C emulator code 
 * (c) Copyright 1997 - 1999 Ivar (ivar@snes9x.com) and
 *                           Gary Henderson.
 * Super FX assembler emulator code (c) Copyright 1998 zsKnight and _Demo_.
 *
 * DSP1 emulator code (c) Copyright 1998 Ivar, _Demo_ and Gary Henderson.
 * C4 asm and some C emulation code (c) Copyright 2000 zsKnight and _Demo_.
 * C4 C code (c) Copyright 2001 Gary Henderson (gary.henderson@ntlworld.com).
 *
 * DOS port code contains the works of other authors. See headers in
 * individual files.
 *
 * Snes9x homepage: http://www.snes9x.com
 *
 * Permission to use, copy, modify and distribute Snes9x in both binary and
 * source form, for non-commercial purposes, is hereby granted without fee,
 * providing that this license information and copyright notice appear with
 * all copies and any derived work.
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event shall the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Snes9x is freeware for PERSONAL USE only. Commercial users should
 * seek permission of the copyright holders first. Commercial use includes
 * charging money for Snes9x or software derived from Snes9x.
 *
 * The copyright holders request that bug fixes and improvements to the code
 * should be forwarded to them so everyone can benefit from the modifications
 * in future versions.
 *
 * Super NES and Super Nintendo Entertainment System are trademarks of
 * Nintendo Co., Limited and its subsidiary companies.
 */

#include "snes9x.h"
#include "spc700.h"
#include "apu.h"
#include "soundux.h"
#include "cpuexec.h"

/* For note-triggered SPC dump support */
//#include "snapshot.h"

//extern int NoiseFreq [32];
#ifdef DEBUGGER
void S9xTraceSoundDSP (const char *s, int i1 = 0, int i2 = 0, int i3 = 0,
		       int i4 = 0, int i5 = 0, int i6 = 0, int i7 = 0);
#endif

#undef ABS
#define ABS(a) ((a) < 0 ? -(a) : (a))
#define ENVX_SHIFT 24


unsigned long AttackRate [16] = {
	4100, 2600, 1500, 1000, 640, 380, 260, 160,
	96, 64, 40, 24, 16, 10, 6, 1
};

unsigned long DecayRate [8] = {
	1200, 740, 440, 290, 180, 110, 74, 37
};

unsigned long SustainRate [32] = {
	/*~0*/0xFFFFFFFF, 38000, 28000, 24000, 19000, 14000, 12000, 9400,
	7100, 5900, 4700, 3500, 2900, 2400, 1800, 1500,
	1200, 880, 740, 590, 440, 370, 290, 220,
	180, 150, 110, 92, 74, 55, 37, 18
};
	
unsigned long IncreaseRate [32] = {
	/*~0*/0xFFFFFFFF, 4100, 3100, 2600, 2000, 1500, 1300, 1000,
	770, 640, 510, 380, 320, 260, 190, 160,
	130, 96, 80, 64, 48, 40, 32, 24,
	20, 16, 12, 10, 8, 6, 4, 2
};

unsigned long DecreaseRateExp [32] = {
	/*~0*/0xFFFFFFFF, 38000, 28000, 24000, 19000, 14000, 12000, 9400,
	7100, 5900, 4700, 3500, 2900, 2400, 1800, 1500,
	1200, 880, 740, 590, 440, 370, 290, 220,
	180, 150, 110, 92, 74, 55, 37, 18
};	

// precalculated env rates for S9xSetEnvRate
unsigned long AttackERate     [16][10];
unsigned long DecayERate       [8][10];
unsigned long SustainERate    [32][10];
unsigned long IncreaseERate   [32][10];
unsigned long DecreaseERateExp[32][10];
unsigned long KeyOffERate[10];


static inline void S9xSetEnvelopeRate (int channel, unsigned long rate, int direction, int target, unsigned int mode)
{
    S9xSetEnvRate (&SoundData.channels [channel], rate, direction, target, mode);
}

static inline void S9xSetSoundADSR (int channel, int attack_ind, int decay_ind,
		      int sustain_ind, int sustain_level, int release_rate)
{
	int attack_rate = AttackRate [attack_ind];
	int decay_rate = DecayRate [decay_ind];
	int sustain_rate = SustainRate [sustain_ind];
	
	// Hack for ROMs that use a very short attack rate, key on a 
	// channel, then switch to decay mode. e.g. Final Fantasy II.
	if (attack_rate == 1)
		attack_rate = 0;

	SoundData.channels[channel].env_ind_attack = attack_ind;
    SoundData.channels[channel].env_ind_decay = decay_ind;
    SoundData.channels[channel].env_ind_sustain = sustain_ind;

	SoundData.channels[channel].attack_rate = attack_rate;
    SoundData.channels[channel].decay_rate = decay_rate;
    SoundData.channels[channel].sustain_rate = sustain_rate;
    SoundData.channels[channel].release_rate = release_rate;
    SoundData.channels[channel].sustain_level = sustain_level + 1;

    switch (SoundData.channels[channel].state)
    {
    case SOUND_ATTACK:
	S9xSetEnvelopeRate (channel, attack_rate, 1, 127, 0);
	break;

    case SOUND_DECAY:
	S9xSetEnvelopeRate (channel, decay_rate, -1,
			    (MAX_ENVELOPE_HEIGHT * (sustain_level + 1)) >> 3, 1<<28);
	break;
    case SOUND_SUSTAIN:
	S9xSetEnvelopeRate (channel, sustain_rate, -1, 0, 2<<28);
	break;
    }
}

static inline void S9xSetSoundVolume (int channel, short volume_left, short volume_right)
{
    Channel *ch = &SoundData.channels[channel];
    if (!so.stereo)
	volume_left = (ABS(volume_right) + ABS(volume_left)) / 2;

    ch->volume_left = volume_left;
    ch->volume_right = volume_right;
    ch-> left_vol_level = (ch->envx * volume_left) / 128;
    ch->right_vol_level = (ch->envx * volume_right) / 128;
}

static inline void S9xSetMasterVolume (short volume_left, short volume_right)
{
    if (Settings.DisableMasterVolume)
    {
	SoundData.master_volume_left = 127;
	SoundData.master_volume_right = 127;
	SoundData.master_volume [0] = SoundData.master_volume [1] = 127;
    }
    else
    {
	if (!so.stereo)
	    volume_left = (ABS (volume_right) + ABS (volume_left)) / 2;
	SoundData.master_volume_left = volume_left;
	SoundData.master_volume_right = volume_right;
	SoundData.master_volume [0] = volume_left;
	SoundData.master_volume [1] = volume_right;
    }
}

static inline void S9xSetEchoVolume (short volume_left, short volume_right)
{
    if (!so.stereo)
	volume_left = (ABS (volume_right) + ABS (volume_left)) / 2;
    SoundData.echo_volume_left = volume_left;
    SoundData.echo_volume_right = volume_right;
    SoundData.echo_volume [0] = volume_left;
    SoundData.echo_volume [1] = volume_right;
}

static inline void S9xSetEchoWriteEnable (uint8 byte)
{
    SoundData.echo_write_enabled = byte;
    S9xSetEchoDelay (APU.DSP [APU_EDL] & 15);
}

static inline void S9xSetFrequencyModulationEnable (uint8 byte)
{
    SoundData.pitch_mod = byte & (0xFE);//~1;
}

static inline int S9xGetEnvelopeHeight (int channel)
{
    if ((Settings.SoundEnvelopeHeightReading ||
	 SNESGameFixes.SoundEnvelopeHeightReading2) &&
        SoundData.channels[channel].state != SOUND_SILENT &&
        SoundData.channels[channel].state != SOUND_GAIN)
    {
        return (SoundData.channels[channel].envx);
    }

    //siren fix from XPP
    if (SNESGameFixes.SoundEnvelopeHeightReading2 &&
        SoundData.channels[channel].state != SOUND_SILENT)
    {
        return (SoundData.channels[channel].envx);
    }

    return (0);
}

static inline void S9xSetSoundHertz (int channel, int hertz)
{
    SoundData.channels[channel].hertz = hertz;
    S9xSetSoundFrequency (channel, hertz);
}

static inline void S9xSetSoundType (int channel, int type_of_sound)
{
    SoundData.channels[channel].type = type_of_sound;
}

static inline bool8 S9xSetSoundMode (int channel, int mode)
{
    Channel *ch = &SoundData.channels[channel];

    switch (mode)
    {
    case MODE_RELEASE:
	if (ch->mode != MODE_NONE)
	{
	    ch->mode = MODE_RELEASE;
	    return (TRUE);
	}
	break;
	
    case MODE_DECREASE_LINEAR:
    case MODE_DECREASE_EXPONENTIAL:
    case MODE_GAIN:
	if (ch->mode != MODE_RELEASE)
	{
	    ch->mode = mode;
	    if (ch->state != SOUND_SILENT)
		ch->state = mode;

	    return (TRUE);
	}
	break;

    case MODE_INCREASE_LINEAR:
    case MODE_INCREASE_BENT_LINE:
	if (ch->mode != MODE_RELEASE)
	{
	    ch->mode = mode;
	    if (ch->state != SOUND_SILENT)
		ch->state = mode;

	    return (TRUE);
	}
	break;

    case MODE_ADSR:
	if (ch->mode == MODE_NONE || ch->mode == MODE_ADSR)
	{
	    ch->mode = mode;
	    return (TRUE);
	}
    }

    return (FALSE);
}

static inline void S9xPlaySample (int channel)
{
    Channel *ch = &SoundData.channels[channel];
    
    ch->state = SOUND_SILENT;
    ch->mode = MODE_NONE;
    ch->envx = 0;
    ch->envxx = 0;

	ch->g_index=0;
	ch->gaussian[0]=ch->gaussian[1]=ch->gaussian[2]=ch->gaussian[3]=0;

    S9xFixEnvelope (channel,
		    APU.DSP [APU_GAIN  + (channel << 4)], 
		    APU.DSP [APU_ADSR1 + (channel << 4)],
		    APU.DSP [APU_ADSR2 + (channel << 4)]);

    ch->sample_number = APU.DSP [APU_SRCN + channel * 0x10];
    if (APU.DSP [APU_NON] & (1 << channel))
	ch->type = SOUND_NOISE;
    else
	ch->type = SOUND_SAMPLE;

    S9xSetSoundFrequency (channel, ch->hertz);
    ch->loop = FALSE;
    ch->needs_decode = TRUE;
    ch->last_block = FALSE;
    ch->previous [0] = ch->previous[1] = 0;
    ch->block_pointer = *S9xGetSampleAddress(ch->sample_number);
    ch->sample_pointer = 0;
    ch->env_error = 0;
    ch->next_sample = 0;
    ch->interpolate = 0;
    ch->last_valid_header=0;
    switch (ch->mode)
    {
    case MODE_ADSR:
	if (ch->attack_rate == 0)
	{
	    if (ch->decay_rate == 0 || ch->sustain_level == 8)
	    {
		ch->state = SOUND_SUSTAIN;
		ch->envx = (MAX_ENVELOPE_HEIGHT * ch->sustain_level) >> 3;
		S9xSetEnvRate (ch, ch->sustain_rate, -1, 0, 2<<28);
	    }
	    else
	    {
		ch->state = SOUND_DECAY;
		ch->envx = MAX_ENVELOPE_HEIGHT;
		S9xSetEnvRate (ch, ch->decay_rate, -1, 
				    (MAX_ENVELOPE_HEIGHT * ch->sustain_level) >> 3, 1<<28);
	    }
	    ch-> left_vol_level = (ch->envx * ch->volume_left) / 128;
	    ch->right_vol_level = (ch->envx * ch->volume_right) / 128;
	}
	else
	{
	    ch->state = SOUND_ATTACK;
	    ch->envx = 0;
	    ch->left_vol_level = 0;
	    ch->right_vol_level = 0;
	    S9xSetEnvRate (ch, ch->attack_rate, 1, MAX_ENVELOPE_HEIGHT, 0);
	}
	ch->envxx = ch->envx << ENVX_SHIFT;
	break;

    case MODE_GAIN:
	ch->state = SOUND_GAIN;
	break;

    case MODE_INCREASE_LINEAR:
	ch->state = SOUND_INCREASE_LINEAR;
	break;

    case MODE_INCREASE_BENT_LINE:
	ch->state = SOUND_INCREASE_BENT_LINE;
	break;

    case MODE_DECREASE_LINEAR:
	ch->state = SOUND_DECREASE_LINEAR;
	break;

    case MODE_DECREASE_EXPONENTIAL:
	ch->state = SOUND_DECREASE_EXPONENTIAL;
	break;

    default:
	break;
    }

    S9xFixEnvelope (channel,
		    APU.DSP [APU_GAIN  + (channel << 4)], 
		    APU.DSP [APU_ADSR1 + (channel << 4)],
		    APU.DSP [APU_ADSR2 + (channel << 4)]);
}

#ifdef ASM_SPC700
extern "C" uint32 Spc700JumpTab;
#endif

bool8 S9xInitAPU ()
{
	// notaz
	memset(&IAPU, 0, sizeof(IAPU));
	IAPU.ExtraRAM = APU.ExtraRAM;
#ifdef ASM_SPC700
	IAPU.asmJumpTab = &Spc700JumpTab;
#endif

	IAPU.RAM = (uint8 *) malloc (0x10000);
    IAPU.ShadowRAM = NULL;//(uint8 *) malloc (0x10000);
    IAPU.CachedSamples = NULL;//(uint8 *) malloc (0x40000);
    
    if (!IAPU.RAM /*|| !IAPU.ShadowRAM || !IAPU.CachedSamples*/)
    {
	S9xDeinitAPU ();
	return (FALSE);
    }

    return (TRUE);
}

void S9xDeinitAPU ()
{
    if (IAPU.RAM)
    {
	free ((char *) IAPU.RAM);
	IAPU.RAM = NULL;
    }
    if (IAPU.ShadowRAM)
    {
	free ((char *) IAPU.ShadowRAM);
	IAPU.ShadowRAM = NULL;
    }
    if (IAPU.CachedSamples)
    {
	free ((char *) IAPU.CachedSamples);
	IAPU.CachedSamples = NULL;
    }
}

EXTERN_C uint8 APUROM [64];

void S9xResetAPU ()
{
//    Settings.APUEnabled = Settings.NextAPUEnabled;

    memset (IAPU.RAM, Settings.APURAMInitialValue, 0x10000);
    //memset (IAPU.ShadowRAM, Settings.APURAMInitialValue, 0x10000);
    
    //ZeroMemory (IAPU.CachedSamples, 0x40000);
    ZeroMemory (APU.OutPorts, 4);
    IAPU.DirectPage = IAPU.RAM;
    memmove (&IAPU.RAM [0xffc0], APUROM, sizeof (APUROM));
    memmove (APU.ExtraRAM, APUROM, sizeof (APUROM));
    IAPU.PC = IAPU.RAM + IAPU.RAM [0xfffe] + (IAPU.RAM [0xffff] << 8);
    CPU.APU_Cycles = 0;
    IAPU.YA.W = 0;
    IAPU.X = 0;
    IAPU.S = 0xff;
    IAPU.P = 0;
    S9xAPUUnpackStatus ();
    CPU.APU_APUExecuting = Settings.APUEnabled;
#ifdef SPC700_SHUTDOWN
    IAPU.WaitAddress1 = NULL;
    IAPU.WaitAddress2 = NULL;
    IAPU.WaitCounter = 0;
#endif
    APU.ShowROM = TRUE;
    IAPU.RAM [0xf1] = 0x80;

    int i;

    for (i = 0; i < 3; i++)
    {
	APU.TimerEnabled [i] = FALSE;
	APU.TimerValueWritten [i] = 0;
	APU.TimerTarget [i] = 0;
	APU.Timer [i] = 0;
    }
    for (int j = 0; j < 0x80; j++)
	APU.DSP [j] = 0;

    IAPU.TwoCycles = IAPU.OneCycle * 2;

    for (i = 0; i < 256; i++)
	S9xAPUCycles [i] = S9xAPUCycleLengths [i] * IAPU.OneCycle;

    APU.DSP [APU_ENDX] = 0;
    APU.DSP [APU_KOFF] = 0;
    APU.DSP [APU_KON] = 0;
    APU.DSP [APU_FLG] = APU_MUTE | APU_ECHO_DISABLED;
    APU.KeyedChannels = 0;

    S9xResetSound (TRUE);
    S9xSetEchoEnable (0);
}

extern int framecpto;
void S9xSetAPUDSP (uint8 byte)
{
    uint8 reg = IAPU.RAM [0xf2];
	static uint8 KeyOn;
	static uint8 KeyOnPrev;
    int i;
    
/*    char str[64];
    if (byte!=0)
    {
		sprintf(str,"fr : %d\nwrite dsp %d\ncpu cycle=%d pc=%04X",framecpto,byte,CPU.Cycles,CPU.PC-CPU.PCBase);
		S9xMessage(0,0,str);
		gp32_pause();
	}*/

	//extern uint8 spc_dump_dsp[0x100];

	//spc_dump_dsp[reg] = byte;

    switch (reg)
    {
    case APU_FLG:
	if (byte & APU_SOFT_RESET)
	{
	    APU.DSP [reg] = APU_MUTE | APU_ECHO_DISABLED | (byte & 0x1f);
	    APU.DSP [APU_ENDX] = 0;
	    APU.DSP [APU_KOFF] = 0;
	    APU.DSP [APU_KON] = 0;
	    S9xSetEchoWriteEnable (FALSE);
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] DSP reset\n", ICPU.Scanline);
#endif
	    // Kill sound
	    S9xResetSound (FALSE);
	}
	else
	{
	    S9xSetEchoWriteEnable (!(byte & APU_ECHO_DISABLED));
	    if (byte & APU_MUTE)
	    {
#ifdef DEBUGGER
		if (Settings.TraceSoundDSP)
		    S9xTraceSoundDSP ("[%d] Mute sound\n", ICPU.Scanline);
#endif
		S9xSetSoundMute (TRUE);
	    }
	    else
		S9xSetSoundMute (FALSE);

	    SoundData.noise_hertz = NoiseFreq [byte & 0x1f];
	    for (i = 0; i < 8; i++)
	    {
		if (SoundData.channels [i].type == SOUND_NOISE)
		    S9xSetSoundFrequency (i, SoundData.noise_hertz);
	    }
	}
	break;
    case APU_NON:
	if (byte != APU.DSP [APU_NON])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Noise:", ICPU.Scanline);
#endif
	    uint8 mask = 1;
	    for (int c = 0; c < 8; c++, mask <<= 1)
	    {
		int type;
		if (byte & mask)
		{
		    type = SOUND_NOISE;
#ifdef DEBUGGER
		    if (Settings.TraceSoundDSP)
		    {
			if (APU.DSP [reg] & mask)
			    S9xTraceSoundDSP ("%d,", c);
			else
			    S9xTraceSoundDSP ("%d(on),", c);
		    }
#endif
		}
		else
		{
		    type = SOUND_SAMPLE;
#ifdef DEBUGGER
		    if (Settings.TraceSoundDSP)
		    {
			if (APU.DSP [reg] & mask)
			    S9xTraceSoundDSP ("%d(off),", c);
		    }
#endif
		}
		S9xSetSoundType (c, type);
	    }
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("\n");
#endif
	}
	break;
    case APU_MVOL_LEFT:
	if (byte != APU.DSP [APU_MVOL_LEFT])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Master volume left:%d\n", 
				  ICPU.Scanline, (signed char) byte);
#endif
		S9xSetMasterVolume ((signed char) byte,
				    (signed char) APU.DSP [APU_MVOL_RIGHT]);
	}
	break;
    case APU_MVOL_RIGHT:
	if (byte != APU.DSP [APU_MVOL_RIGHT])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Master volume right:%d\n",
				  ICPU.Scanline, (signed char) byte);
#endif
		S9xSetMasterVolume ((signed char) APU.DSP [APU_MVOL_LEFT],
				    (signed char) byte);
	}
	break;
    case APU_EVOL_LEFT:
	if (byte != APU.DSP [APU_EVOL_LEFT])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Echo volume left:%d\n",
				  ICPU.Scanline, (signed char) byte);
#endif
		S9xSetEchoVolume ((signed char) byte,
				  (signed char) APU.DSP [APU_EVOL_RIGHT]);
	}
	break;
    case APU_EVOL_RIGHT:
	if (byte != APU.DSP [APU_EVOL_RIGHT])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Echo volume right:%d\n",
				  ICPU.Scanline, (signed char) byte);
#endif
		S9xSetEchoVolume ((signed char) APU.DSP [APU_EVOL_LEFT],
				  (signed char) byte);
	}
	break;
    case APU_ENDX:
#ifdef DEBUGGER
	if (Settings.TraceSoundDSP)
	    S9xTraceSoundDSP ("[%d] Reset ENDX\n", ICPU.Scanline);
#endif
	byte = 0;
	break;

    case APU_KOFF:
		//		if (byte)
	{
	    uint8 mask = 1;
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Key off:", ICPU.Scanline);
#endif
	    for (int c = 0; c < 8; c++, mask <<= 1)
	    {
		if ((byte & mask) != 0)
		{
#ifdef DEBUGGER

		    if (Settings.TraceSoundDSP)
			S9xTraceSoundDSP ("%d,", c);
#endif		    
		    if (APU.KeyedChannels & mask)
		    {
			{
							KeyOnPrev&=~mask;
			    APU.KeyedChannels &= ~mask;
			    APU.DSP [APU_KON] &= ~mask;
			    //APU.DSP [APU_KOFF] |= mask;
			    S9xSetSoundKeyOff (c);
			}
		    }
		}
				else if((KeyOnPrev&mask)!=0)
				{
					KeyOnPrev&=~mask;
					APU.KeyedChannels |= mask;
					//APU.DSP [APU_KON] |= mask;
					APU.DSP [APU_KOFF] &= ~mask;
					APU.DSP [APU_ENDX] &= ~mask;
					S9xPlaySample (c);
				}
	    }
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("\n");
#endif
	}
		//KeyOnPrev=0;
	APU.DSP [APU_KOFF] = byte;
	return;
    case APU_KON:

	if (byte)
	{
	    uint8 mask = 1;
#ifdef DEBUGGER

	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] Key on:", ICPU.Scanline);
#endif
	    for (int c = 0; c < 8; c++, mask <<= 1)
	    {
		if ((byte & mask) != 0)
		{
#ifdef DEBUGGER
		    if (Settings.TraceSoundDSP)
			S9xTraceSoundDSP ("%d,", c);
#endif		    
		    // Pac-In-Time requires that channels can be key-on
		    // regardeless of their current state.
					if((APU.DSP [APU_KOFF] & mask) ==0)
					{
						KeyOnPrev&=~mask;
		    APU.KeyedChannels |= mask;
						//APU.DSP [APU_KON] |= mask;
						//APU.DSP [APU_KOFF] &= ~mask;
		    APU.DSP [APU_ENDX] &= ~mask;
		    S9xPlaySample (c);
		}
					else KeyOn|=mask;
				}
	    }
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("\n");
#endif
	}
	//spc_is_dumping_temp = byte;
	return;
	
    case APU_VOL_LEFT + 0x00:
    case APU_VOL_LEFT + 0x10:
    case APU_VOL_LEFT + 0x20:
    case APU_VOL_LEFT + 0x30:
    case APU_VOL_LEFT + 0x40:
    case APU_VOL_LEFT + 0x50:
    case APU_VOL_LEFT + 0x60:
    case APU_VOL_LEFT + 0x70:
// At Shin Megami Tensei suggestion 6/11/00
//	if (byte != APU.DSP [reg])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] %d volume left: %d\n", 
				  ICPU.Scanline, reg>>4, (signed char) byte);
#endif
		S9xSetSoundVolume (reg >> 4, (signed char) byte,
				   (signed char) APU.DSP [reg + 1]);
	}
	break;
    case APU_VOL_RIGHT + 0x00:
    case APU_VOL_RIGHT + 0x10:
    case APU_VOL_RIGHT + 0x20:
    case APU_VOL_RIGHT + 0x30:
    case APU_VOL_RIGHT + 0x40:
    case APU_VOL_RIGHT + 0x50:
    case APU_VOL_RIGHT + 0x60:
    case APU_VOL_RIGHT + 0x70:
// At Shin Megami Tensei suggestion 6/11/00
//	if (byte != APU.DSP [reg])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] %d volume right: %d\n", 
				  ICPU.Scanline, reg >>4, (signed char) byte);
#endif
		S9xSetSoundVolume (reg >> 4, (signed char) APU.DSP [reg - 1],
				   (signed char) byte);
	}
	break;

    case APU_P_LOW + 0x00:
    case APU_P_LOW + 0x10:
    case APU_P_LOW + 0x20:
    case APU_P_LOW + 0x30:
    case APU_P_LOW + 0x40:
    case APU_P_LOW + 0x50:
    case APU_P_LOW + 0x60:
    case APU_P_LOW + 0x70:
#ifdef DEBUGGER
	if (Settings.TraceSoundDSP)
	    S9xTraceSoundDSP ("[%d] %d freq low: %d\n",
			      ICPU.Scanline, reg>>4, byte);
#endif
	    S9xSetSoundHertz (reg >> 4, (((byte + (APU.DSP [reg + 1] << 8)) & FREQUENCY_MASK) * 32000) >> 12);
	break;

    case APU_P_HIGH + 0x00:
    case APU_P_HIGH + 0x10:
    case APU_P_HIGH + 0x20:
    case APU_P_HIGH + 0x30:
    case APU_P_HIGH + 0x40:
    case APU_P_HIGH + 0x50:
    case APU_P_HIGH + 0x60:
    case APU_P_HIGH + 0x70:
#ifdef DEBUGGER
	if (Settings.TraceSoundDSP)
	    S9xTraceSoundDSP ("[%d] %d freq high: %d\n",
			      ICPU.Scanline, reg>>4, byte);
#endif
	    S9xSetSoundHertz (reg >> 4, 
			(((byte << 8) + APU.DSP [reg - 1]) & FREQUENCY_MASK) * 8);
	break;

    case APU_SRCN + 0x00:
    case APU_SRCN + 0x10:
    case APU_SRCN + 0x20:
    case APU_SRCN + 0x30:
    case APU_SRCN + 0x40:
    case APU_SRCN + 0x50:
    case APU_SRCN + 0x60:
    case APU_SRCN + 0x70:
	if (byte != APU.DSP [reg])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] %d sample number: %d\n",
				  ICPU.Scanline, reg>>4, byte);
#endif
	    //S9xSetSoundSample (reg >> 4, byte); // notaz: seems to be unused?
	}
	break;
	
    case APU_ADSR1 + 0x00:
    case APU_ADSR1 + 0x10:
    case APU_ADSR1 + 0x20:
    case APU_ADSR1 + 0x30:
    case APU_ADSR1 + 0x40:
    case APU_ADSR1 + 0x50:
    case APU_ADSR1 + 0x60:
    case APU_ADSR1 + 0x70:
	if (byte != APU.DSP [reg])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] %d adsr1: %02x\n",
				  ICPU.Scanline, reg>>4, byte);
#endif
	    {
		S9xFixEnvelope (reg >> 4, APU.DSP [reg + 2], byte, 
			     APU.DSP [reg + 1]);
	    }
	}
	break;

    case APU_ADSR2 + 0x00:
    case APU_ADSR2 + 0x10:
    case APU_ADSR2 + 0x20:
    case APU_ADSR2 + 0x30:
    case APU_ADSR2 + 0x40:
    case APU_ADSR2 + 0x50:
    case APU_ADSR2 + 0x60:
    case APU_ADSR2 + 0x70:
	if (byte != APU.DSP [reg])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] %d adsr2: %02x\n", 
				  ICPU.Scanline, reg>>4, byte);
#endif
	    {
		S9xFixEnvelope (reg >> 4, APU.DSP [reg + 1], APU.DSP [reg - 1],
			     byte);
	    }
	}
	break;

    case APU_GAIN + 0x00:
    case APU_GAIN + 0x10:
    case APU_GAIN + 0x20:
    case APU_GAIN + 0x30:
    case APU_GAIN + 0x40:
    case APU_GAIN + 0x50:
    case APU_GAIN + 0x60:
    case APU_GAIN + 0x70:
	if (byte != APU.DSP [reg])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
		S9xTraceSoundDSP ("[%d] %d gain: %02x\n",
				  ICPU.Scanline, reg>>4, byte);
#endif
	    {
		S9xFixEnvelope (reg >> 4, byte, APU.DSP [reg - 2],
			     APU.DSP [reg - 1]);
	    }
	}
	break;

    case APU_ENVX + 0x00:
    case APU_ENVX + 0x10:
    case APU_ENVX + 0x20:
    case APU_ENVX + 0x30:
    case APU_ENVX + 0x40:
    case APU_ENVX + 0x50:
    case APU_ENVX + 0x60:
    case APU_ENVX + 0x70:
	break;

    case APU_OUTX + 0x00:
    case APU_OUTX + 0x10:
    case APU_OUTX + 0x20:
    case APU_OUTX + 0x30:
    case APU_OUTX + 0x40:
    case APU_OUTX + 0x50:
    case APU_OUTX + 0x60:
    case APU_OUTX + 0x70:
	break;
    
    case APU_DIR:
#ifdef DEBUGGER
	if (Settings.TraceSoundDSP)
	    S9xTraceSoundDSP ("[%d] Sample directory to: %02x\n",
			      ICPU.Scanline, byte);
#endif
	break;

    case APU_PMON:
	if (byte != APU.DSP [APU_PMON])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
	    {
		S9xTraceSoundDSP ("[%d] FreqMod:", ICPU.Scanline);
		uint8 mask = 1;
		for (int c = 0; c < 8; c++, mask <<= 1)
		{
		    if (byte & mask)
		    {
			if (APU.DSP [reg] & mask)
			    S9xTraceSoundDSP ("%d", c);
			else
			    S9xTraceSoundDSP ("%d(on),", c);
		    }
		    else
		    {
			if (APU.DSP [reg] & mask)
			    S9xTraceSoundDSP ("%d(off),", c);
		    }
		}
		S9xTraceSoundDSP ("\n");
	    }
#endif
		S9xSetFrequencyModulationEnable (byte);
	}
	break;

    case APU_EON:
	if (byte != APU.DSP [APU_EON])
	{
#ifdef DEBUGGER
	    if (Settings.TraceSoundDSP)
	    {
		S9xTraceSoundDSP ("[%d] Echo:", ICPU.Scanline);
		uint8 mask = 1;
		for (int c = 0; c < 8; c++, mask <<= 1)
		{
		    if (byte & mask)
		    {
			if (APU.DSP [reg] & mask)
			    S9xTraceSoundDSP ("%d", c);
			else
			    S9xTraceSoundDSP ("%d(on),", c);
		    }
		    else
		    {
			if (APU.DSP [reg] & mask)
			    S9xTraceSoundDSP ("%d(off),", c);
		    }
		}
		S9xTraceSoundDSP ("\n");
	    }
#endif
		S9xSetEchoEnable (byte);
	}
	break;

    case APU_EFB:
	S9xSetEchoFeedback ((signed char) byte);
	break;

    case APU_ESA:
	break;

    case APU_EDL:
	S9xSetEchoDelay (byte & 0xf);
	break;

    case APU_C0:
    case APU_C1:
    case APU_C2:
    case APU_C3:
    case APU_C4:
    case APU_C5:
    case APU_C6:
    case APU_C7:
	S9xSetFilterCoefficient (reg >> 4, (signed char) byte);
	break;
    default:
// XXX
//printf ("Write %02x to unknown APU register %02x\n", byte, reg);
	break;
    }

	KeyOnPrev|=KeyOn;
	KeyOn=0;
	
    if (reg < 0x80)
	APU.DSP [reg] = byte;
}

void S9xFixEnvelope (int channel, uint8 gain, uint8 adsr1, uint8 adsr2)
{
    if (adsr1 & 0x80)
    {
		// ADSR mode
		
		// XXX: can DSP be switched to ADSR mode directly from GAIN/INCREASE/
		// DECREASE mode? And if so, what stage of the sequence does it start
		// at?
		if (S9xSetSoundMode (channel, MODE_ADSR))
		{
			S9xSetSoundADSR (channel, adsr1 & 0xf, (adsr1 >> 4) & 7, adsr2 & 0x1f, (adsr2 >> 5) & 7, 8);
		}
    }
    else
    {
		// Gain mode
		if ((gain & 0x80) == 0)
		{
			if (S9xSetSoundMode (channel, MODE_GAIN))
			{
			S9xSetEnvelopeRate (channel, 0, 0, gain & 0x7f, 0);
			S9xSetEnvelopeHeight (channel, gain & 0x7f);
			}
		}
		else
		{
			
			if (gain & 0x40)
			{
				// Increase mode
				if (S9xSetSoundMode (channel, (gain & 0x20) ?
							  MODE_INCREASE_BENT_LINE :
							  MODE_INCREASE_LINEAR))
				{
					S9xSetEnvelopeRate (channel, IncreaseRate [gain & 0x1f], 1, 127, (3<<28)|gain);
				}
			}
			else
			{
				if(gain & 0x20) {
					if (S9xSetSoundMode (channel, MODE_DECREASE_EXPONENTIAL))
						S9xSetEnvelopeRate (channel, DecreaseRateExp [gain & 0x1f] / 2, -1, 0, (4<<28)|gain);
				} else {
					if (S9xSetSoundMode (channel, MODE_DECREASE_LINEAR))
						S9xSetEnvelopeRate (channel, IncreaseRate [gain & 0x1f], -1, 0, (3<<28)|gain);
				}
			}
		}
    }
}

void S9xSetAPUControl (uint8 byte)
{
//if (byte & 0x40)
//printf ("*** Special SPC700 timing enabled\n");
    if ((byte & 1) != 0 && !APU.TimerEnabled [0])
    {
	APU.Timer [0] = 0;
	IAPU.RAM [0xfd] = 0;
	if ((APU.TimerTarget [0] = IAPU.RAM [0xfa]) == 0)
	    APU.TimerTarget [0] = 0x100;
    }
    if ((byte & 2) != 0 && !APU.TimerEnabled [1])
    {
	APU.Timer [1] = 0;
	IAPU.RAM [0xfe] = 0;
	if ((APU.TimerTarget [1] = IAPU.RAM [0xfb]) == 0)
	    APU.TimerTarget [1] = 0x100;
    }
    if ((byte & 4) != 0 && !APU.TimerEnabled [2])
    {
	APU.Timer [2] = 0;
	IAPU.RAM [0xff] = 0;
	if ((APU.TimerTarget [2] = IAPU.RAM [0xfc]) == 0)
	    APU.TimerTarget [2] = 0x100;
    }
    APU.TimerEnabled [0] = byte & 1;
    APU.TimerEnabled [1] = (byte & 2) >> 1;
    APU.TimerEnabled [2] = (byte & 4) >> 2;

    if (byte & 0x10)
	IAPU.RAM [0xF4] = IAPU.RAM [0xF5] = 0;

    if (byte & 0x20)
	IAPU.RAM [0xF6] = IAPU.RAM [0xF7] = 0;

    if (byte & 0x80)
    {
	if (!APU.ShowROM)
	{
	    memmove (&IAPU.RAM [0xffc0], APUROM, sizeof (APUROM));
	    APU.ShowROM = TRUE;
	}
    }
    else
    {
	if (APU.ShowROM)
	{
	    APU.ShowROM = FALSE;
	    memmove (&IAPU.RAM [0xffc0], APU.ExtraRAM, sizeof (APUROM));
	}
    }
    IAPU.RAM [0xf1] = byte;
}

void S9xSetAPUTimer (uint16 Address, uint8 byte)
{
    IAPU.RAM [Address] = byte;

    switch (Address)
    {
    case 0xfa:
	if ((APU.TimerTarget [0] = IAPU.RAM [0xfa]) == 0)
	    APU.TimerTarget [0] = 0x100;
	APU.TimerValueWritten [0] = TRUE;
	break;
    case 0xfb:
	if ((APU.TimerTarget [1] = IAPU.RAM [0xfb]) == 0)
	    APU.TimerTarget [1] = 0x100;
	APU.TimerValueWritten [1] = TRUE;
	break;
    case 0xfc:
	if ((APU.TimerTarget [2] = IAPU.RAM [0xfc]) == 0)
	    APU.TimerTarget [2] = 0x100;
	APU.TimerValueWritten [2] = TRUE;
	break;
    }
}

uint8 S9xGetAPUDSP ()
{
    uint8 reg = IAPU.RAM [0xf2] & 0x7f;
    uint8 byte = APU.DSP [reg];

    switch (reg)
    {
    case APU_KON:
	break;
    case APU_KOFF:
	break;
    case APU_OUTX + 0x00:
    case APU_OUTX + 0x10:
    case APU_OUTX + 0x20:
    case APU_OUTX + 0x30:
    case APU_OUTX + 0x40:
    case APU_OUTX + 0x50:
    case APU_OUTX + 0x60:
    case APU_OUTX + 0x70:
	if (SoundData.channels [reg >> 4].state == SOUND_SILENT)
	    return (0);
	return ((SoundData.channels [reg >> 4].sample >> 8) |
		(SoundData.channels [reg >> 4].sample & 0xff));

    case APU_ENVX + 0x00:
    case APU_ENVX + 0x10:
    case APU_ENVX + 0x20:
    case APU_ENVX + 0x30:
    case APU_ENVX + 0x40:
    case APU_ENVX + 0x50:
    case APU_ENVX + 0x60:
    case APU_ENVX + 0x70:
		return 0;
//		return ((uint8) S9xGetEnvelopeHeight (reg >> 4));

    case APU_ENDX:
// To fix speech in Magical Drop 2 6/11/00
//	APU.DSP [APU_ENDX] = 0;
	break;
    default:
	break;
    }
    return (byte);
}
